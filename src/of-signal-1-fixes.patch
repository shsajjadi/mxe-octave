# HG changeset patch
# User Mike Miller <mtmiller@octave.org>
# Date 1525815613 25200
# Node ID 3cbff3de1ebcb28a87ca0e0f8342ea393db19908
# Parent  36e6b83ee1a1b178c58c14c5077038d7a6614118
medfilt1: rewrite memory management, fix build error on MinGW (bug #53849)

* medfilt1.cc (sorted_window::sorted_window): Make buf a unique_ptr. Use
member initialiation list. (sorted_window::~sorted_window): Delete.
(sorted_window::init): Use fill_n instead of bzero. (sorted_window::replace,
sorted_window::add, sorted_window::remove): Update syntax to dereference
offsets into buf.

diff -r 36e6b83ee1a1 -r 3cbff3de1ebc src/medfilt1.cc
--- a/src/medfilt1.cc	Sun May 06 10:17:15 2018 +0200
+++ b/src/medfilt1.cc	Tue May 08 14:40:13 2018 -0700
@@ -27,9 +27,8 @@
  One dimensional median filter, for real double variables.
  */
 
-//#ifdef HAVE_CONFIG_H
-//#  include "config.h"
-//#endif
+#include <algorithm>
+#include <memory>
 
 #include "oct.h"
 #include "defun-dld.h"
@@ -44,7 +43,7 @@
 // Keeps NaNs at the "top" (after Inf)
 class sorted_window
 {
-  double *buf;
+  std::unique_ptr<double[]> buf;
   octave_idx_type  numel;
   octave_idx_type  numNaN;
   bool nan_if_any_is;
@@ -70,16 +69,8 @@
   // If  skip_nan  then the median will consider only valid numbers within
   // the window.  
   sorted_window (octave_idx_type width, bool skip_nan = true)
-    {
-      numel = 0;
-      nan_if_any_is = ! skip_nan;
-      buf = new double [width];
-    }
-
-  ~sorted_window ()
-    {
-      delete [] buf;
-    }
+    : buf (new double [width]), numel (0), numNaN (0),
+      nan_if_any_is (! skip_nan) { }
 
   // Initialize to contain  seed,  and  zeros  additional zeros.
   void init (const double *seed, octave_idx_type num, octave_idx_type stride,
@@ -88,7 +79,7 @@
       numel = zeros;
       numNaN = 0;
 
-      bzero (buf, zeros * sizeof (double));
+      std::fill_n (&buf[0], zeros, 0.0);
 
       // Insert from seed.  Could sort if it is large
       num *= stride;
@@ -106,7 +97,7 @@
           n_pos = find (next);
           p_pos = find (prev, n_pos);
           if (n_pos != p_pos)
-            std::copy_backward (buf + n_pos, buf + p_pos, buf + p_pos + 1);
+            std::copy_backward (&buf[n_pos], &buf[p_pos], &buf[p_pos + 1]);
         }
       else if (next > prev)
         {
@@ -114,7 +105,7 @@
           n_pos = find (next, p_pos);
           if (n_pos != p_pos)
             {
-              std::copy (buf + p_pos + 1, buf + n_pos, buf + p_pos);
+              std::copy (&buf[p_pos + 1], &buf[n_pos], &buf[p_pos]);
               n_pos--;            // position shifts due to deletion of p_pos
             }
         }
@@ -123,13 +114,13 @@
           if (next == next)
             {
               n_pos = find (next);
-              std::copy_backward (buf + n_pos, buf + numel - 1, buf + numel);
+              std::copy_backward (&buf[n_pos], &buf[numel - 1], &buf[numel]);
               numNaN--;
             }
           else if (prev == prev)
             {
               p_pos = find (prev);
-              std::copy (buf + p_pos + 1, buf + numel, buf + p_pos);
+              std::copy (&buf[p_pos + 1], &buf[numel], &buf[p_pos]);
               n_pos = numel - 1;
               numNaN++;
             }
@@ -151,7 +142,7 @@
         {
           n_pos = find (next);
           if (n_pos < numel)
-            std::copy_backward (buf + n_pos, buf + numel, buf + numel + 1);
+            std::copy_backward (&buf[n_pos], &buf[numel], &buf[numel + 1]);
         }
       else              // NaN stored at end, so nothing to move.
         {
@@ -170,7 +161,7 @@
       if (prev == prev)
         {
           p_pos = find (prev);
-          std::copy (buf + p_pos + 1, buf + numel, buf + p_pos);
+          std::copy (&buf[p_pos + 1], &buf[numel], &buf[p_pos]);
         }
       else                  // NaN stored at end, so nothing to move.
         numNaN--;

