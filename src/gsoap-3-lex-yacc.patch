This file is part of mingw-cross-env.
See doc/index.html or doc/README for further information.

diff -urN d/gsoap/src/Makefile.in e/gsoap/src/Makefile.in
--- d/gsoap/src/Makefile.in	2010-01-24 11:54:01.000000000 +0100
+++ e/gsoap/src/Makefile.in	2010-01-24 12:21:23.000000000 +0100
@@ -202,7 +202,7 @@
 soapcpp2_CFLAGS = $(BISON_DEFINE) $(LEX_DEFINE) $(C_DEBUG_FLAGS) $(SOAPCPP2_IMPORTPATH) -D$(platform)
 soapcpp2_LDADD = $(YACC_LIB) $(LEXLIB)
 soapcpp2_SOURCES = soapcpp2_yacc.y soapcpp2_lex.l symbol2.c error2.c init2.c soapcpp2.c
-CLEANFILES = *~ soapcpp2_lex.c soapcpp2_yacc.c soapcpp2_yacc.h y.output soapcpp2_yacc.output
+CLEANFILES = *~
 all: all-am
 
 .SUFFIXES:
diff -urN d/gsoap/src/soapcpp2_lex.c e/gsoap/src/soapcpp2_lex.c
--- d/gsoap/src/soapcpp2_lex.c	1970-01-01 01:00:00.000000000 +0100
+++ e/gsoap/src/soapcpp2_lex.c	2010-01-24 12:13:25.000000000 +0100
@@ -0,0 +1,3079 @@
+
+#line 3 "soapcpp2_lex.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
+     *       access to the local variable yy_act. Since yyless() is a macro, it would break
+     *       existing scanners that call yyless() from OUTSIDE yylex. 
+     *       One obvious solution it to make yy_act a global. I tried that, and saw
+     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
+     *       normally declared as a register variable-- so it is not worth it.
+     */
+    #define  YY_LESS_LINENO(n) \
+            do { \
+                int yyl;\
+                for ( yyl = n; yyl < yyleng; ++yyl )\
+                    if ( yytext[yyl] == '\n' )\
+                        --yylineno;\
+            }while(0)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+#define YY_FLEX_LEX_COMPAT
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char yytext[];
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	if ( yyleng + (yy_more_offset) >= YYLMAX ) \
+		YY_FATAL_ERROR( "token too large, exceeds YYLMAX" ); \
+	yy_flex_strncpy( &yytext[(yy_more_offset)], (yytext_ptr), yyleng + 1 ); \
+	yyleng += (yy_more_offset); \
+	(yy_prev_more_offset) = (yy_more_offset); \
+	(yy_more_offset) = 0; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 42
+#define YY_END_OF_BUFFER 43
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_acclist[130] =
+    {   0,
+       43,   41,   42,    1,   41,   42,    1,   42,   29,   41,
+       42,   41,   42,16424,   41,   42,   29,   41,   42,   29,
+       41,   42,   41,   42,16423,   29,   41,   42,   29,   41,
+       42,   29,   41,   42,   29,   41,   42,   29,   41,   42,
+       31,   41,   42,   31,   41,   42,   29,   41,   42,   29,
+       41,   42,   29,   41,   42,   30,   41,   42,   29,   41,
+       42,   29,   41,   42,    3,   42,    3,   42,   21,16424,
+     8232,   35,16424,   38,   12,   19,   13,16423, 8231,   34,
+    16423,   10,   26,    8,   27,    9,   28,    2,   11,   31,
+       24,   22,   20,   23,   25,   30,   14,   15,   18,    4,
+
+     8232,   35,   34,    7,   33,   33,   32,   16,   17,   33,
+       38,   38,    6,    7,   37,   38,   37,   36,   38,   36,
+       37,   38,   37,   36,   38,   36,    5,    6,    7
+    } ;
+
+static yyconst flex_int16_t yy_accept[133] =
+    {   0,
+        1,    1,    1,    1,    1,    2,    4,    7,    9,   12,
+       15,   17,   20,   23,   26,   29,   32,   35,   38,   41,
+       44,   47,   50,   53,   56,   59,   62,   65,   67,   69,
+       70,   71,   72,   73,   74,   74,   75,   75,   75,   76,
+       77,   78,   79,   80,   81,   82,   83,   84,   85,   86,
+       87,   88,   89,   89,   90,   90,   91,   91,   91,   92,
+       93,   94,   95,   96,   97,   97,   98,   99,  100,  101,
+      101,  101,  102,  103,  103,  103,  104,  104,  105,  105,
+      106,  106,  107,  108,  109,  110,  110,  110,  110,  110,
+      110,  110,  110,  110,  110,  110,  110,  111,  111,  111,
+
+      111,  111,  111,  111,  111,  112,  112,  113,  113,  115,
+      115,  115,  115,  117,  117,  117,  118,  118,  118,  120,
+      120,  120,  121,  121,  123,  124,  126,  127,  127,  127,
+      130,  130
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    2,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    7,    8,    9,   10,
+       10,   11,   12,   10,   13,   14,   15,   16,   17,   17,
+       17,   17,   17,   17,   17,   17,   17,   18,   10,   19,
+       20,   21,   10,   10,   22,   22,   22,   22,   23,   22,
+       24,   24,   24,   24,   24,   24,   24,   24,   24,   24,
+       24,   24,   24,   24,   24,   24,   24,   25,   24,   24,
+       10,   26,   10,   27,   24,    1,   28,   22,   22,   29,
+
+       30,   22,   31,   24,   32,   24,   24,   33,   34,   24,
+       35,   36,   24,   37,   38,   39,   40,   24,   24,   25,
+       24,   24,   10,   41,   10,   10,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[42] =
+    {   0,
+        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    3,    3,    4,    1,    1,
+        1,    3,    3,    4,    4,    1,    1,    3,    3,    3,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        1
+    } ;
+
+static yyconst flex_int16_t yy_base[147] =
+    {   0,
+        0,    0,  266,  265,  275,  278,  278,  278,  254,   39,
+       40,  253,   37,   43,  278,  226,   35,   38,   51,   59,
+       47,   29,  197,   33,  198,  195,   40,  278,  198,  278,
+       75,   62,  278,   80,  209,  278,   53,   65,  278,  278,
+      278,   83,  278,  278,   87,  278,  278,  278,  278,  278,
+      278,  278,   76,  278,   77,   81,  102,    0,  191,  278,
+      278,  278,  190,  191,   86,  278,  278,  278,  278,   86,
+      105,   94,  100,  113,  114,  112,  205,  278,  119,  107,
+      111,  116,    0,  278,  278,  120,  126,  131,  126,  127,
+      137,  138,  136,  141,  138,  131,  142,  139,  153,  157,
+
+      160,  162,  142,  165,  167,  173,  177,  204,  278,  178,
+      203,  182,  184,  202,  186,  188,  201,  192,  194,  200,
+      196,  198,  179,  278,  278,  278,  278,  199,  189,  278,
+      278,  218,  222,  226,  230,  232,  236,  240,   47,  244,
+      248,  252,  256,  260,  264,  268
+    } ;
+
+static yyconst flex_int16_t yy_def[147] =
+    {   0,
+      131,    1,  132,  132,  131,  131,  131,  131,  131,  133,
+      134,  131,  131,  135,  131,  131,  131,  131,  131,  131,
+      131,  131,  131,  131,  136,  131,  131,  131,  131,  131,
+      133,  137,  131,  133,  134,  131,  134,  134,  131,  131,
+      131,  135,  131,  131,  135,  131,  131,  131,  131,  131,
+      131,  131,  138,  131,  131,  131,  131,  139,  131,  131,
+      131,  131,  131,  136,  136,  131,  131,  131,  131,  137,
+      137,  137,  137,  134,  134,  140,  138,  131,  138,  131,
+      131,  131,  139,  131,  131,  137,  134,  134,  140,  140,
+      138,  131,  134,  134,  138,  131,  131,  134,  134,  138,
+
+      134,  134,  141,  142,  143,  144,  145,  141,  131,  141,
+      142,  142,  143,  143,  143,  143,  144,  144,  145,  145,
+      145,  145,  141,  131,  131,  131,  131,  146,  146,  131,
+        0,  131,  131,  131,  131,  131,  131,  131,  131,  131,
+      131,  131,  131,  131,  131,  131
+    } ;
+
+static yyconst flex_int16_t yy_nxt[320] =
+    {   0,
+        6,    7,    8,    9,   10,   11,   12,   13,   14,   15,
+       16,   17,   18,   15,   19,   20,   21,   15,   22,   23,
+       24,   25,   25,   25,   25,    6,   26,   25,   25,   25,
+       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
+       27,   32,   36,   33,   40,   43,   47,   59,   60,   83,
+       49,   44,   62,   63,   48,   36,   41,   50,   51,   67,
+       55,   52,   56,   56,   34,   53,   33,   36,   45,   57,
+       54,   37,   55,   38,   56,   56,   57,   32,   78,   33,
+       68,   57,   72,   58,   73,   43,   74,   71,   57,   43,
+       33,   44,   80,   80,   55,   76,   56,   56,   33,   75,
+
+       34,  131,  131,   57,   33,   34,   79,   86,   45,   73,
+       57,   71,   45,   81,   81,   36,   36,   82,   82,   71,
+       44,   78,   80,   80,   33,   71,   82,   82,   36,   92,
+       71,   82,   82,   36,   44,   76,   92,   90,   36,   78,
+       78,   36,   88,   36,  109,   71,   97,   97,   87,   96,
+       96,   90,   90,   97,   97,   36,   91,   97,   97,   78,
+       93,  104,  105,  106,  107,  100,  112,  113,  115,  116,
+       94,   95,   98,   99,  118,  119,  110,  101,  121,  122,
+      109,  109,  102,  112,  113,  115,  116,  115,  116,  115,
+      116,  130,  103,  118,  119,  121,  122,  121,  122,  121,
+
+      122,  130,  127,  126,  125,  124,  109,   78,   65,   85,
+       84,   36,   69,  123,   66,   65,   61,  128,   28,   28,
+       28,   28,   31,   31,   31,   31,   35,   35,   35,   35,
+       42,   42,   42,   42,   64,   64,   70,   70,   70,   70,
+       77,   77,   77,   77,   89,   46,   89,   89,  108,  108,
+      108,  108,  111,  111,  111,  111,  114,  114,  114,  114,
+      117,  117,  117,  117,  120,  120,  120,  120,  129,  129,
+      129,  129,   39,   30,  131,   29,   29,    5,  131,  131,
+      131,  131,  131,  131,  131,  131,  131,  131,  131,  131,
+      131,  131,  131,  131,  131,  131,  131,  131,  131,  131,
+
+      131,  131,  131,  131,  131,  131,  131,  131,  131,  131,
+      131,  131,  131,  131,  131,  131,  131,  131,  131
+    } ;
+
+static yyconst flex_int16_t yy_chk[320] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,   10,   11,   10,   13,   14,   17,   22,   22,  139,
+       18,   14,   24,   24,   17,   37,   13,   18,   18,   27,
+       21,   19,   21,   21,   10,   19,   32,   38,   14,   21,
+       19,   11,   20,   11,   20,   20,   21,   31,   53,   31,
+       27,   20,   34,   20,   34,   42,   37,   32,   20,   45,
+       70,   42,   55,   55,   56,   45,   56,   56,   72,   38,
+
+       31,   65,   65,   56,   73,   34,   53,   71,   42,   71,
+       56,   70,   45,   57,   57,   74,   75,   57,   57,   72,
+       76,   79,   80,   80,   86,   73,   81,   81,   87,   80,
+       71,   82,   82,   88,   89,   90,   80,   76,   93,   91,
+       95,   98,   75,   94,  103,   86,   96,   96,   74,   92,
+       92,   89,   90,   92,   92,   99,   79,   97,   97,  100,
+       87,  101,  101,  102,  102,   95,  104,  104,  105,  105,
+       88,   91,   93,   94,  106,  106,  103,   98,  107,  107,
+      110,  123,   99,  112,  112,  113,  113,  115,  115,  116,
+      116,  129,  100,  118,  118,  119,  119,  121,  121,  122,
+
+      122,  128,  120,  117,  114,  111,  108,   77,   64,   63,
+       59,   35,   29,  110,   26,   25,   23,  123,  132,  132,
+      132,  132,  133,  133,  133,  133,  134,  134,  134,  134,
+      135,  135,  135,  135,  136,  136,  137,  137,  137,  137,
+      138,  138,  138,  138,  140,   16,  140,  140,  141,  141,
+      141,  141,  142,  142,  142,  142,  143,  143,  143,  143,
+      144,  144,  144,  144,  145,  145,  145,  145,  146,  146,
+      146,  146,   12,    9,    5,    4,    3,  131,  131,  131,
+      131,  131,  131,  131,  131,  131,  131,  131,  131,  131,
+      131,  131,  131,  131,  131,  131,  131,  131,  131,  131,
+
+      131,  131,  131,  131,  131,  131,  131,  131,  131,  131,
+      131,  131,  131,  131,  131,  131,  131,  131,  131
+    } ;
+
+/* Table of booleans, true if rule could match eol. */
+static yyconst flex_int32_t yy_rule_can_match_eol[43] =
+    {   0,
+1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 
+    1, 0, 0,     };
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
+static char *yy_full_match;
+static int yy_lp;
+static int yy_looking_for_trail_begin = 0;
+static int yy_full_lp;
+static int *yy_full_state;
+#define YY_TRAILING_MASK 0x2000
+#define YY_TRAILING_HEAD_MASK 0x4000
+#define REJECT \
+{ \
+*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
+yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
+(yy_lp) = (yy_full_lp); /* restore orig. accepting pos. */ \
+(yy_state_ptr) = (yy_full_state); /* restore orig. state */ \
+yy_current_state = *(yy_state_ptr); /* restore curr. state */ \
+++(yy_lp); \
+goto find_rule; \
+}
+
+static int yy_more_offset = 0;
+static int yy_prev_more_offset = 0;
+#define yymore() ((yy_more_offset) = yy_flex_strlen( yytext ))
+#define YY_NEED_STRLEN
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET \
+	{ \
+	(yy_more_offset) = (yy_prev_more_offset); \
+	yyleng -= (yy_more_offset); \
+	}
+#ifndef YYLMAX
+#define YYLMAX 8192
+#endif
+
+char yytext[YYLMAX];
+char *yytext_ptr;
+#line 1 "soapcpp2_lex.l"
+/*
+	soapcpp2_lex.l
+
+	Flex/Lex tokenizer.
+
+--------------------------------------------------------------------------------
+gSOAP XML Web services tools
+Copyright (C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
+This part of the software is released under ONE of the following licenses:
+GPL, the gSOAP public license, OR Genivia's license for commercial use.
+--------------------------------------------------------------------------------
+gSOAP public license.
+
+The contents of this file are subject to the gSOAP Public License Version 1.3
+(the "License"); you may not use this file except in compliance with the
+License. You may obtain a copy of the License at
+http://www.cs.fsu.edu/~engelen/soaplicense.html
+Software distributed under the License is distributed on an "AS IS" basis,
+WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+for the specific language governing rights and limitations under the License.
+
+The Initial Developer of the Original Code is Robert A. van Engelen.
+Copyright (C) 2000-2008 Robert A. van Engelen, Genivia inc. All Rights Reserved.
+--------------------------------------------------------------------------------
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen@genivia.com / engelen@acm.org
+
+This program is released under the GPL with the additional exemption that
+compiling, linking, and/or using OpenSSL is allowed.
+--------------------------------------------------------------------------------
+A commercial use license is available from Genivia, Inc., contact@genivia.com
+--------------------------------------------------------------------------------
+*/
+#line 51 "soapcpp2_lex.l"
+#include "soapcpp2.h"
+
+#ifdef HAVE_CONFIG_H
+#include "soapcpp2_yacc.h"
+#else
+#include "soapcpp2_yacc.tab.h"
+#endif
+
+#ifdef WITH_BISON
+YYSTYPE yylval;
+#undef YY_INPUT
+#define YY_INPUT(buf, result, max_size) \
+	{ \
+	int c = getc(yyin); \
+	result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \
+	}
+#endif
+
+#ifndef WITH_LEX
+#define MAX_IMPORT_DEPTH 16
+static struct importlist { struct importlist *next; char name[1]; } *importlist = NULL;
+static char fnstk[MAX_IMPORT_DEPTH][1024];
+static int lnstk[MAX_IMPORT_DEPTH];
+static char *imstk[MAX_IMPORT_DEPTH];
+static YY_BUFFER_STATE instk[MAX_IMPORT_DEPTH];
+#endif
+int imports = 0;
+char *imported = NULL;
+static void check_id(const char*);
+static Token install_id();
+static Token install_int();
+static Token install_hex();
+static Token install_num();
+static Token install_chr();
+static Token install_str();
+static Token install_pragma();
+static void directive(), option();
+static Token error_chr();
+static Token error_str();
+static int convchar(int*);
+static int hexchar(int*);
+static int octchar(int*);
+static void module(const char *name, const char *fullname);
+static void import(const char *file);
+static int magic(const char *name);
+
+#line 728 "soapcpp2_lex.c"
+
+#define INITIAL 0
+#define MLCOMMENT 1
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		int n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 109 "soapcpp2_lex.l"
+
+#line 913 "soapcpp2_lex.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+        /* Create the reject buffer large enough to save one state per allowed character. */
+        if ( ! (yy_state_buf) )
+            (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
+            if ( ! (yy_state_buf) )
+                YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+
+		(yy_state_ptr) = (yy_state_buf);
+		*(yy_state_ptr)++ = yy_current_state;
+
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 132 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			*(yy_state_ptr)++ = yy_current_state;
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 278 );
+
+yy_find_action:
+		yy_current_state = *--(yy_state_ptr);
+		(yy_lp) = yy_accept[yy_current_state];
+find_rule: /* we branch to this label when backing up */
+		for ( ; ; ) /* until we find what rule we matched */
+			{
+			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
+				{
+				yy_act = yy_acclist[(yy_lp)];
+				if ( yy_act & YY_TRAILING_HEAD_MASK ||
+				     (yy_looking_for_trail_begin) )
+					{
+					if ( yy_act == (yy_looking_for_trail_begin) )
+						{
+						(yy_looking_for_trail_begin) = 0;
+						yy_act &= ~YY_TRAILING_HEAD_MASK;
+						break;
+						}
+					}
+				else if ( yy_act & YY_TRAILING_MASK )
+					{
+					(yy_looking_for_trail_begin) = yy_act & ~YY_TRAILING_MASK;
+					(yy_looking_for_trail_begin) |= YY_TRAILING_HEAD_MASK;
+					(yy_full_match) = yy_cp;
+					(yy_full_state) = (yy_state_ptr);
+					(yy_full_lp) = (yy_lp);
+					}
+				else
+					{
+					(yy_full_match) = yy_cp;
+					(yy_full_state) = (yy_state_ptr);
+					(yy_full_lp) = (yy_lp);
+					break;
+					}
+				++(yy_lp);
+				goto find_rule;
+				}
+			--yy_cp;
+			yy_current_state = *--(yy_state_ptr);
+			(yy_lp) = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
+			{
+			int yyl;
+			for ( yyl = (yy_prev_more_offset); yyl < yyleng; ++yyl )
+				if ( yytext[yyl] == '\n' )
+					   
+    yylineno++;
+;
+			}
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+/* rule 1 can match eol */
+YY_RULE_SETUP
+#line 110 "soapcpp2_lex.l"
+{ /* skip white space */ }
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 111 "soapcpp2_lex.l"
+{ BEGIN(MLCOMMENT); }
+	YY_BREAK
+case 3:
+/* rule 3 can match eol */
+YY_RULE_SETUP
+#line 112 "soapcpp2_lex.l"
+{ }
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 113 "soapcpp2_lex.l"
+{ BEGIN(INITIAL); }
+	YY_BREAK
+case YY_STATE_EOF(MLCOMMENT):
+#line 114 "soapcpp2_lex.l"
+{ execerror("Unclosed multiline comment at the end of file"); }
+	YY_BREAK
+case 5:
+/* rule 5 can match eol */
+YY_RULE_SETUP
+#line 115 "soapcpp2_lex.l"
+{ option(); }
+	YY_BREAK
+case 6:
+/* rule 6 can match eol */
+YY_RULE_SETUP
+#line 116 "soapcpp2_lex.l"
+{ directive(); }
+	YY_BREAK
+case 7:
+/* rule 7 can match eol */
+YY_RULE_SETUP
+#line 117 "soapcpp2_lex.l"
+{ /* skip single line comment */ }
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 118 "soapcpp2_lex.l"
+{ return PA; }
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 119 "soapcpp2_lex.l"
+{ return NA; }
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 120 "soapcpp2_lex.l"
+{ return TA; }
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 121 "soapcpp2_lex.l"
+{ return DA; }
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 122 "soapcpp2_lex.l"
+{ return MA; }
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 123 "soapcpp2_lex.l"
+{ return AA; }
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 124 "soapcpp2_lex.l"
+{ return XA; }
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 125 "soapcpp2_lex.l"
+{ return OA; }
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 126 "soapcpp2_lex.l"
+{ return LA; }
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 127 "soapcpp2_lex.l"
+{ return RA; }
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 128 "soapcpp2_lex.l"
+{ return OR; }
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 129 "soapcpp2_lex.l"
+{ return AN; }
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 130 "soapcpp2_lex.l"
+{ return EQ; }
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 131 "soapcpp2_lex.l"
+{ return NE; }
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 132 "soapcpp2_lex.l"
+{ return LE; }
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 133 "soapcpp2_lex.l"
+{ return GE; }
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 134 "soapcpp2_lex.l"
+{ return LS; }
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 135 "soapcpp2_lex.l"
+{ return RS; }
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 136 "soapcpp2_lex.l"
+{ return PP; }
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 137 "soapcpp2_lex.l"
+{ return NN; }
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 138 "soapcpp2_lex.l"
+{ return AR; }
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 139 "soapcpp2_lex.l"
+{ return yytext[0]; }
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 140 "soapcpp2_lex.l"
+{ return install_id(); }
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 141 "soapcpp2_lex.l"
+{ return install_int(); }
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 142 "soapcpp2_lex.l"
+{ return install_hex(); }
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 143 "soapcpp2_lex.l"
+{ return install_num(); }
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 144 "soapcpp2_lex.l"
+{ return install_chr(); }
+	YY_BREAK
+case 35:
+/* rule 35 can match eol */
+YY_RULE_SETUP
+#line 145 "soapcpp2_lex.l"
+{ return install_str(); }
+	YY_BREAK
+case 36:
+/* rule 36 can match eol */
+YY_RULE_SETUP
+#line 146 "soapcpp2_lex.l"
+{ char *s, *t, buf[1024];
+			  s = strchr(yytext, '"');
+			  if (!s)
+			    t = yytext+7;
+			  else
+			  { strcpy(buf, s+1);
+			    s = strchr(buf, '"');
+			    *s = '\0';
+			    t = strchr(s+1, '"');
+			    if (t)
+			    { t++;
+			      s = strchr(t+1, '"');
+			      if (s)
+			        *s = '\0';
+			    }
+			  }
+			  module(buf, t);
+			}
+	YY_BREAK
+case 37:
+/* rule 37 can match eol */
+YY_RULE_SETUP
+#line 164 "soapcpp2_lex.l"
+{ char *s, buf[1024];
+			  s = strchr(yytext, '"');
+			  if (s)
+			  { strcpy(buf, s+1);
+			    s = strchr(buf, '"');
+			    *s = '\0';
+			    import(buf);
+			  }
+			  else
+		            lexerror("Invalid import directive");
+			}
+	YY_BREAK
+case 38:
+/* rule 38 can match eol */
+YY_RULE_SETUP
+#line 175 "soapcpp2_lex.l"
+{ return install_pragma(); }
+	YY_BREAK
+case 39:
+/* rule 39 can match eol */
+YY_RULE_SETUP
+#line 176 "soapcpp2_lex.l"
+{ return error_chr(); }
+	YY_BREAK
+case 40:
+/* rule 40 can match eol */
+YY_RULE_SETUP
+#line 177 "soapcpp2_lex.l"
+{ return error_str(); }
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 178 "soapcpp2_lex.l"
+{ lexerror("Skipping unknown symbol"); }
+	YY_BREAK
+case YY_STATE_EOF(INITIAL):
+#line 179 "soapcpp2_lex.l"
+{ /* when Lex complains: remove this line and below */
+#ifndef WITH_LEX
+			  if (--imports < 0)
+			    yyterminate();
+			  else
+			  { yy_delete_buffer(YY_CURRENT_BUFFER);
+			    yy_switch_to_buffer(instk[imports]);
+			    strcpy(filename, fnstk[imports]);
+			    yylineno = lnstk[imports];
+			    imported = imstk[imports];
+			  }
+#endif
+			}
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 192 "soapcpp2_lex.l"
+ECHO;
+	YY_BREAK
+#line 1306 "soapcpp2_lex.c"
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			YY_FATAL_ERROR(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	(yy_state_ptr) = (yy_state_buf);
+	*(yy_state_ptr)++ = yy_current_state;
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 132 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		*(yy_state_ptr)++ = yy_current_state;
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    
+	register YY_CHAR yy_c = 1;
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 132 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 131);
+	if ( ! yy_is_jam )
+		*(yy_state_ptr)++ = yy_current_state;
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+    if ( c == '\n' ){
+        --yylineno;
+    }
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	if ( c == '\n' )
+		   
+    yylineno++;
+;
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    /* We do not touch yylineno unless the option is enabled. */
+    yylineno =  1;
+    
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+    (yy_state_buf) = 0;
+    (yy_state_ptr) = 0;
+    (yy_full_match) = 0;
+    (yy_lp) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    yyfree ( (yy_state_buf) );
+    (yy_state_buf)  = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 192 "soapcpp2_lex.l"
+
+
+
+/*
+	install_id - lookup identifier in symbol table. If found, return token
+	and symbol table entry. If not found, create entry in symbol table and
+	return ID token.
+*/ 
+static Token
+install_id()
+{	Symbol *p = lookup(yytext);
+	if (!p)
+	{	int i, flag = 0;
+		p = install(yytext, ID);
+		/* [_](x|X)(m|M)(l|L)__ is OK */
+		/* [_](x|X)(m|M)(l|L).* is not OK */
+		/* .*__(x|X)(m|M)(l|L) is not OK */
+		/* .*::(x|X)(m|M)(l|L) is not OK */
+		for (i = 0; i < yyleng; i++)
+		{	if ((yytext[i] == '_' && yytext[i+1] == '_')
+			 || (yytext[i] == ':' && yytext[i+1] == ':'))
+			{	flag = 1;
+				check_id(yytext + i + 2);
+			}
+		}
+		if (!flag && strcmp(yytext, "XML"))
+			check_id(yytext);
+	}
+	yylval.sym = p;
+	return p->token;
+}
+
+/*
+	check_id - check for (x|X)(m|M)(l|L)
+*/
+static void
+check_id(const char *s)
+{	while (*s == '_')
+		s++;
+	if ((s[0] == 'x' || s[0] == 'X')
+	 && (s[1] == 'm' || s[1] == 'M')
+	 && (s[2] == 'l' || s[2] == 'L'))
+	{	sprintf(errbuf, "identifier '%s' starts with or embeds illegal '%3.3s' character sequence (for enum constants: please ignore this warning)", yytext, s);
+		semwarn(errbuf);
+	}
+}
+
+/*
+	install_int - convert digits to integer and return LNG token.
+*/
+static Token
+install_int()
+{
+	sscanf(yytext, SOAP_ULONG_FORMAT, &yylval.i);
+	return LNG;
+}
+
+/*
+	install_hex - convert hexadecimal digits to integer and return LNG
+*/
+static Token
+install_hex()
+{
+	sscanf(yytext, SOAP_XLONG_FORMAT, &yylval.i);
+	return LNG;
+}
+
+/*
+	install_num - convert digits to floating point number and return DBL
+*/
+static Token
+install_num()
+{	sscanf(yytext, "%lf", &yylval.r);
+	return DBL;
+}
+
+/*
+	install_chr - convert character constant and return CHR.
+*/
+static Token
+install_chr()
+{	int i = 2;
+	if (yytext[1] == '\\')
+		yylval.c = convchar(&i);
+	else	yylval.c = yytext[i-1];
+	if (yytext[i] != '\'')
+		lexerror("Illegal character constant");
+	return CHR;
+}
+
+/*
+	install_str - convert and store string in memory. Return STR.
+*/
+static Token
+install_str()
+{	int i, j = 0;
+	yylval.s = emalloc(yyleng-1);	/* yyleng = length(yytext) */
+	for (i = 1; i < yyleng-1; i++)
+		if (yytext[i] == '\\')
+		{	if (yytext[++i] != '\n')
+			{	yylval.s[j++] = convchar(&i);
+				i--;
+			}
+		}
+		else
+			yylval.s[j++] = yytext[i];
+	yylval.s[j] = '\0';
+	return STR;
+}
+
+/*
+	install_pragma - store pragma in string. Return PRAGMA.
+*/
+static Token
+install_pragma()
+{	yylval.s = emalloc(yyleng);	/* yyleng = length(yytext) */
+	strncpy(yylval.s, yytext, strlen(yytext)-1);
+	yylval.s[strlen(yytext)-1] = '\0';
+	return PRAGMA;
+}
+
+static void directive()
+{	int i, j, k;
+	char *s;
+	Service *sp;
+	Method *m;
+	Data *d;
+	int service;
+	for (i = 7; yytext[i]; i++)
+		if (yytext[i] > 32)
+			break;
+	for (j = i; yytext[j]; j++)
+		if (yytext[j] <= 32)
+			break;
+	if (i == j)
+		return;
+	s = (char*)emalloc(j-i+1);
+	for (k = 0; k < j-i; k++)
+	{ s[k] = yytext[k+i];
+	  if (s[k] == '_')
+	    s[k] = '-';
+	}
+	s[k] = '\0';
+	for (sp = services; sp; sp = sp->next)
+		if (!strcmp(sp->ns, s))
+			break;
+	if (!sp)
+	{	sp = (Service*)emalloc(sizeof(Service));
+		sp->next = services;
+		sp->ns = s;
+		sp->name = NULL;
+		sp->porttype = NULL;
+		sp->portname = NULL;
+		sp->binding = NULL;
+		sp->definitions = NULL;
+		sp->transport = NULL;
+		sp->URL = NULL;
+		sp->URI = NULL;
+		sp->WSDL = NULL;
+		sp->style = NULL;
+		sp->encoding = NULL;
+		sp->elementForm = NULL;
+		sp->attributeForm = NULL;
+		sp->executable = NULL;
+		sp->import = NULL;
+		sp->documentation = NULL;
+		sp->list = NULL;
+		sp->data = NULL;
+		services = sp;
+	}
+	for (i = j; yytext[i]; i++)
+		if (yytext[i] > 32)
+			break;
+	if (!strncmp(yytext+i, "service", 7) || !strncmp(yytext+i, "schema", 6))
+	{	service = strncmp(yytext+i, "schema", 6);
+		for (i += 7; yytext[i]; i++)
+			if (yytext[i] > 32)
+				break;
+		for (j = i; yytext[j]; j++)
+			if (yytext[j] <= 32)
+				break;
+		for (; yytext[j]; j++)
+			if (yytext[j] > 32)
+				break;
+		for (k = j; yytext[k]; k++)
+			if (yytext[k] <= 32)
+				break;
+		/*
+		if (j == k)
+			return;
+		*/
+		s = (char*)emalloc(k-j+1);
+		strncpy(s, yytext+j, k-j);
+		s[k-j] = '\0';
+		if (!strncmp(yytext+i, "name:", 5))
+		{	sp->name = s;
+			for (j = k; yytext[j]; j++)
+				if (yytext[j] > 32)
+					break;
+			for (k = j; yytext[k]; k++)
+				if (yytext[k] == 10 || yytext[k] == 13)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+			sp->documentation = s;
+		}
+		else if (!strncmp(yytext+i, "type:", 5))
+			sp->porttype = s;
+		else if (!strncmp(yytext+i, "portType:", 9))
+			sp->porttype = s;
+		else if (!strncmp(yytext+i, "portName:", 9))
+			sp->portname = s;
+		else if (!strncmp(yytext+i, "binding:", 8))
+			sp->binding = s;
+		else if (!strncmp(yytext+i, "definitions:", 12))
+			sp->definitions = s;
+		else if (!strncmp(yytext+i, "documentation:", 14))
+		{	for (k = j; yytext[k]; k++)
+				if (yytext[k] == 10 || yytext[k] == 13)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+			sp->documentation = s;
+		}
+		else if (!strncmp(yytext+i, "transport:", 10))
+			sp->transport = s;
+		else if (!strncmp(yytext+i, "location:", 9) || !strncmp(yytext+i, "port:", 5))
+		{	if (sp->URL)
+			{	char *t = (char*)emalloc(strlen(sp->URL) + strlen(s) + 2);
+				strcpy(t, sp->URL);
+				strcat(t, " ");
+				strcat(t, s);
+				sp->URL = t;
+			}
+			else
+				sp->URL = s;
+			if (!service && !sp->import)
+				sp->import = s;
+		}
+		else if (!strncmp(yytext+i, "executable:", 11))
+			sp->executable = s;
+		else if (!strncmp(yytext+i, "namespace:", 10))
+		{	if (service)
+			{	if (!sp->URI)
+					sp->URI = s;
+				sp->WSDL = s;
+			}
+			else if (!strcmp(sp->ns, "SOAP-ENV"))
+			{	if (vflag)
+					semwarn("option -1 or -2 overrides SOAP-ENV namespace");
+				else
+					envURI = s;
+				sp->URI = envURI;
+			}
+			else if (!strcmp(sp->ns, "SOAP-ENC"))
+			{	if (vflag)
+					semwarn("option -1 or -2 overrides SOAP-ENC namespace");
+				else
+					encURI = s;
+				sp->URI = encURI = s;
+			}
+			else
+				sp->URI = s;
+		}
+		else if (!strncmp(yytext+i, "form:", 5))
+		{	sp->elementForm = s;
+			sp->attributeForm = s;
+		}
+		else if (!strncmp(yytext+i, "elementForm:", 12))
+			sp->elementForm = s;
+		else if (!strncmp(yytext+i, "attributeForm:", 14))
+			sp->attributeForm = s;
+		else if (!strncmp(yytext+i, "import:", 7))
+		{	if (!sp->URI)
+				sp->URI = s;
+			sp->import = s;
+		}
+		else if (!strncmp(yytext+i, "encoding:", 9))
+		{	if (!strcmp(s, "encoded"))
+				sp->encoding = "";
+			else
+				sp->encoding = s;
+		}
+		else if (!strncmp(yytext+i, "style:", 6))
+			sp->style = s;
+		else if (!strncmp(yytext+i, "method-style:", 13))
+		{	m = (Method*)emalloc(sizeof(Method));
+			m->name = s;
+			m->mess = STYLE;
+			m->part = NULL;
+			m->next = sp->list;
+			sp->list = m;
+			for (j = k; yytext[j]; j++)
+				if (yytext[j] > 32)
+					break;
+			for (k = j; yytext[k]; k++)
+				if (yytext[k] == 10 || yytext[k] == 13)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+			m->part = s;
+		}
+		else if (!strncmp(yytext+i, "method-encoding:", 16))
+		{	m = (Method*)emalloc(sizeof(Method));
+			m->name = s;
+			m->mess = ENCODING;
+			m->part = NULL;
+			m->next = sp->list;
+			sp->list = m;
+			for (j = k; yytext[j]; j++)
+				if (yytext[j] > 32)
+					break;
+			for (k = j; yytext[k]; k++)
+				if (yytext[k] == 10 || yytext[k] == 13)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+		 	if (strcmp(s, "encoded"))
+				m->part = s;
+			else
+				m->part = "";
+		}
+		else if (!strncmp(yytext+i, "method-response-encoding:", 25))
+		{	m = (Method*)emalloc(sizeof(Method));
+			m->name = s;
+			m->mess = RESPONSE_ENCODING;
+			m->part = NULL;
+			m->next = sp->list;
+			sp->list = m;
+			for (j = k; yytext[j]; j++)
+				if (yytext[j] > 32)
+					break;
+			for (k = j; yytext[k]; k++)
+				if (yytext[k] == 10 || yytext[k] == 13)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+		 	if (strcmp(s, "encoded"))
+				m->part = s;
+			else
+				m->part = "";
+		}
+		else if (!strncmp(yytext+i, "method-documentation:", 21))
+		{	m = (Method*)emalloc(sizeof(Method));
+			m->name = s;
+			m->mess = COMMENT;
+			m->part = NULL;
+			m->next = sp->list;
+			sp->list = m;
+			for (j = k; yytext[j]; j++)
+				if (yytext[j] > 32)
+					break;
+			for (k = j; yytext[k]; k++)
+				if (yytext[k] == 10 || yytext[k] == 13)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+			m->part = s;
+		}
+		else if (!strncmp(yytext+i, "method-action:", 14))
+		{	m = (Method*)emalloc(sizeof(Method));
+			m->name = s;
+			m->mess = ACTION;
+			m->part = NULL;
+			m->next = sp->list;
+			sp->list = m;
+			for (j = k; yytext[j]; j++)
+				if (yytext[j] > 32)
+					break;
+			for (k = j; yytext[k]; k++)
+				if (yytext[k] == 10 || yytext[k] == 13)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+			m->part = s;
+		}
+		else if (!strncmp(yytext+i, "method-response-action:", 23))
+		{	m = (Method*)emalloc(sizeof(Method));
+			m->name = s;
+			m->mess = RESPONSE_ACTION;
+			m->part = NULL;
+			m->next = sp->list;
+			sp->list = m;
+			for (j = k; yytext[j]; j++)
+				if (yytext[j] > 32)
+					break;
+			for (k = j; yytext[k]; k++)
+				if (yytext[k] == 10 || yytext[k] == 13)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+			m->part = s;
+		}
+		else if (!strncmp(yytext+i, "method-mime-type:", 17))
+		{	m = (Method*)emalloc(sizeof(Method));
+			m->name = s;
+			m->mess = MIMEIN | MIMEOUT;
+			m->part = NULL;
+			m->next = sp->list;
+			sp->list = m;
+			for (j = k; yytext[j]; j++)
+				if (yytext[j] > 32)
+					break;
+			for (k = j; yytext[k]; k++)
+				if (yytext[k] <= 32)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+			m->part = s;
+		}
+		else if (!strncmp(yytext+i, "method-input-mime-type:", 23))
+		{	m = (Method*)emalloc(sizeof(Method));
+			m->name = s;
+			m->mess = MIMEIN;
+			m->part = NULL;
+			m->next = sp->list;
+			sp->list = m;
+			for (j = k; yytext[j]; j++)
+				if (yytext[j] > 32)
+					break;
+			for (k = j; yytext[k]; k++)
+				if (yytext[k] <= 32)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+			m->part = s;
+		}
+		else if (!strncmp(yytext+i, "method-output-mime-type:", 24))
+		{	m = (Method*)emalloc(sizeof(Method));
+			m->name = s;
+			m->mess = MIMEOUT;
+			m->part = NULL;
+			m->next = sp->list;
+			sp->list = m;
+			for (j = k; yytext[j]; j++)
+				if (yytext[j] > 32)
+					break;
+			for (k = j; yytext[k]; k++)
+				if (yytext[k] <= 32)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+			m->part = s;
+		}
+		else if (!strncmp(yytext+i, "method-header-part:", 19))
+		{	m = (Method*)emalloc(sizeof(Method));
+			m->name = s;
+			m->mess = HDRIN | HDROUT;
+			m->part = NULL;
+			m->next = sp->list;
+			sp->list = m;
+			for (j = k; yytext[j]; j++)
+				if (yytext[j] > 32)
+					break;
+			for (k = j; yytext[k]; k++)
+				if (yytext[k] <= 32)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+			m->part = s;
+		}
+		else if (!strncmp(yytext+i, "method-input-header-part:", 25))
+		{	m = (Method*)emalloc(sizeof(Method));
+			m->name = s;
+			m->mess = HDRIN;
+			m->part = NULL;
+			m->next = sp->list;
+			sp->list = m;
+			for (j = k; yytext[j]; j++)
+				if (yytext[j] > 32)
+					break;
+			for (k = j; yytext[k]; k++)
+				if (yytext[k] <= 32)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+			m->part = s;
+		}
+		else if (!strncmp(yytext+i, "method-output-header-part:", 26))
+		{	m = (Method*)emalloc(sizeof(Method));
+			m->name = s;
+			m->mess = HDROUT;
+			m->part = NULL;
+			m->next = sp->list;
+			sp->list = m;
+			for (j = k; yytext[j]; j++)
+				if (yytext[j] > 32)
+					break;
+			for (k = j; yytext[k]; k++)
+				if (yytext[k] <= 32)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+			m->part = s;
+		}
+		else if (!strncmp(yytext+i, "method-fault:", 13))
+		{	m = (Method*)emalloc(sizeof(Method));
+			m->name = s;
+			m->mess = FAULT;
+			m->part = NULL;
+			m->next = sp->list;
+			sp->list = m;
+			for (j = k; yytext[j]; j++)
+				if (yytext[j] > 32)
+					break;
+			for (k = j; yytext[k]; k++)
+				if (yytext[k] <= 32)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+			m->part = s;
+		}
+		else if (!strncmp(yytext+i, "type-documentation:", 19))
+		{	d = (Data*)emalloc(sizeof(Data));
+			d->name = s;
+			d->part = NULL;
+			d->next = sp->data;
+			sp->data = d;
+			for (j = k; yytext[j]; j++)
+				if (yytext[j] > 32)
+					break;
+			for (k = j; yytext[k]; k++)
+				if (yytext[k] == 10 || yytext[k] == 13)
+					break;
+			if (j == k)
+				return;
+			s = (char*)emalloc(k-j+1);
+			strncpy(s, yytext+j, k-j);
+			s[k-j] = '\0';
+			d->part = s;
+		}
+		else
+                {	sprintf(errbuf, "unrecognized gsoap directive: %s", yytext+i);
+			semwarn(errbuf);
+		}
+	}
+	else
+        {	sprintf(errbuf, "unrecognized gsoap directive: %s", yytext);
+		semwarn(errbuf);
+	}
+}
+
+static void option()
+{	int i;
+	if (imports)
+        {	sprintf(errbuf, "options directive: %s ignored in imported file(s)", yytext);
+		semwarn(errbuf);
+		return;
+	}
+	for (i = 10; yytext[i]; i++)
+		if (yytext[i] > 32)
+			break;
+	for (; yytext[i]; i++)
+		switch (yytext[i])
+		{	case 'c':
+				cflag = 1;
+				break;
+		 	case 'e':
+				eflag = 1;
+				break;
+		 	case 'n':
+				nflag = 1;
+				break;
+		 	case 'l':
+				lflag = 1;
+				break;
+		 	case 't':
+				tflag = 1;
+				break;
+		 	case 'w':
+				wflag = 1;
+				break;
+			default:
+				if (yytext[i] <= 32)
+					return;
+		}
+}
+
+/*
+	error_chr - lexical error in character constant. Return character 0 to
+	allow parsing to continue
+*/
+static Token
+error_chr()
+{	lexerror("Ending-' missing in character constant");
+	yylval.c = '\0';
+	return CHR;
+}
+
+/*
+	error_str - lexical error in string. Return empty string to allow
+	parsing to continue
+*/
+static Token
+error_str()
+{	lexerror("Ending-\" missing in string");
+	yylval.s = "";
+	return STR;
+}
+
+/*
+	Character conversion functions
+*/
+static int
+convchar(int *p)
+{	switch (yytext[(*p)++])
+	{	case 'a':	return '\a';
+		case 'b':	return '\b';
+		case 'f':	return '\f';
+		case 'n':	return '\n';
+		case 'r':	return '\r';
+		case 't':	return '\t';
+		case 'v':	return '\v';
+		case 'x':	return hexchar(p);
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':	(*p)--;
+				return octchar(p);
+		default:	return yytext[*p-1];
+	}
+}
+
+static int
+hexchar(int *p)
+{	int i, d, c = 0;
+	for (i = 0; isxdigit(d = yytext[*p]) && i < 2; i++)
+	{	c = (c << 4) + (d <= '9' ? d - '0' : toupper(d) - '7');
+		(*p)++;
+	}
+	return c;
+}
+
+static int
+octchar(int *p)
+{	int i, d, c = 0;
+	for (i = 0; (d = yytext[*p]) >= '0' && d <= '7' && i < 3; i++)
+	{	c = (c << 3) + d - '0';
+		(*p)++;
+	}
+	return c;
+}
+
+static void module(const char *name, const char *fullname)
+{ if (!fullname)
+    fullname = name;
+  if (imports)
+  { Pragma **pp;
+    char *s = emalloc(strlen(fullname)+15);
+    sprintf(s, "#include \"%sH.h\"", fullname);
+    for (pp = &pragmas; *pp; pp = &(*pp)->next)
+      if (!strcmp((*pp)->pragma, s))
+        break;
+    if (!*pp)
+    { *pp = (Pragma*)emalloc(sizeof(Pragma));
+      (*pp)->pragma = s;
+      (*pp)->next = NULL;
+    }
+    imported = (char*)emalloc(strlen(fullname)+1);
+    strcpy(imported, fullname);
+    fprintf(stderr, "Importing module '%s'\n\n", fullname);
+  }
+  else
+  { lflag = 1;
+    typeNO = magic(name);
+    prefix = (char*)emalloc(strlen(fullname)+1);
+    strcpy(prefix, fullname);
+    fprintf(stderr, "Compiling module '%s' (magic number = %d)\n\n", fullname, typeNO);
+  }
+}
+
+static int magic(const char *name)
+{ size_t i;
+  int n;
+  if (strlen(name) > 4)
+    semerror("#module name length must not exceed four characters");
+  n = 0;
+  for (i = 0; i < strlen(name); i++)
+    if (name[i] >= 'a' && name[i] <= 'z')
+      n = 26*n + name[i] - 'a';
+    else if (name[i] >= 'A' && name[i] <= 'Z')
+      n = 26*n + name[i] - 'A';
+    else
+      semerror("#module name must be alphabetic and the length must not exceed four characters.\nUse '#module name longname' for longer names.");
+  return 4699*n + 153424;
+}
+
+#ifdef WITH_LEX
+static void import(const char *file)
+{ execerror("Cannot #import: soapcpp2 not compiled with flex");
+}
+#else
+static void import(const char *file)
+{ char buf[1024];
+  struct importlist *p;
+  for (p = importlist; p; p = p->next)
+    if (!strcmp(p->name, file))
+      return;
+  if (imports >= MAX_IMPORT_DEPTH)
+    execerror("Imports nested too deep");
+  instk[imports] = YY_CURRENT_BUFFER;
+  strcpy(fnstk[imports], filename);
+  lnstk[imports] = yylineno;
+  imstk[imports] = imported;
+  /* imported = NULL; this is useful to change the semantics of #import to NOT consider non-module imports to be part of the current module */
+  imports++;
+  if (!(yyin = fopen(file, "r")))
+  { if (importpath)
+    { char *s, *t;
+      s = importpath;
+      do
+      { t = strstr(s, SOAP_PATHSEP);
+        if (t)
+        { if (t - s >= sizeof(buf))
+	    t = s + sizeof(buf) - 1;
+	  strncpy(buf, s, t - s);
+	  buf[t - s] = '\0';
+	  s = t + sizeof(SOAP_PATHSEP) - 1;
+	}
+	else
+        { strcpy(buf, s);
+          s = NULL;
+	}
+        strcat(buf, "/");
+        strcat(buf, file);
+        yyin = fopen(buf, "r");
+      }
+      while (s && !yyin);
+    }
+    if (!yyin)
+    { sprintf(errbuf, "#import: Cannot open file \"%s\" for reading.\nHint: use option -I<path> (you can define multiple paths separated with '"SOAP_PATHSEP"')", file);
+      execerror(errbuf);
+    }
+  }
+  p = (struct importlist*)malloc(sizeof(struct importlist) + strlen(file)); /* has already + 1 byte size */
+  strcpy(p->name, file);
+  p->next = importlist;
+  importlist = p;
+  strcpy(filename, file);
+  yy_switch_to_buffer(yy_create_buffer(yyin,YY_BUF_SIZE));
+}
+#endif
+
diff -urN d/gsoap/src/soapcpp2_yacc.c e/gsoap/src/soapcpp2_yacc.c
--- d/gsoap/src/soapcpp2_yacc.c	1970-01-01 01:00:00.000000000 +0100
+++ e/gsoap/src/soapcpp2_yacc.c	2010-01-24 11:59:51.000000000 +0100
@@ -0,0 +1,4716 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     PRAGMA = 258,
+     AUTO = 259,
+     DOUBLE = 260,
+     INT = 261,
+     STRUCT = 262,
+     BREAK = 263,
+     ELSE = 264,
+     LONG = 265,
+     SWITCH = 266,
+     CASE = 267,
+     ENUM = 268,
+     REGISTER = 269,
+     TYPEDEF = 270,
+     CHAR = 271,
+     EXTERN = 272,
+     RETURN = 273,
+     UNION = 274,
+     CONST = 275,
+     FLOAT = 276,
+     SHORT = 277,
+     UNSIGNED = 278,
+     CONTINUE = 279,
+     FOR = 280,
+     SIGNED = 281,
+     VOID = 282,
+     DEFAULT = 283,
+     GOTO = 284,
+     SIZEOF = 285,
+     VOLATILE = 286,
+     DO = 287,
+     IF = 288,
+     STATIC = 289,
+     WHILE = 290,
+     CLASS = 291,
+     PRIVATE = 292,
+     PROTECTED = 293,
+     PUBLIC = 294,
+     VIRTUAL = 295,
+     INLINE = 296,
+     OPERATOR = 297,
+     LLONG = 298,
+     BOOL = 299,
+     CFALSE = 300,
+     CTRUE = 301,
+     WCHAR = 302,
+     TIME = 303,
+     USING = 304,
+     NAMESPACE = 305,
+     ULLONG = 306,
+     MUSTUNDERSTAND = 307,
+     SIZE = 308,
+     FRIEND = 309,
+     TEMPLATE = 310,
+     EXPLICIT = 311,
+     TYPENAME = 312,
+     RESTRICT = 313,
+     null = 314,
+     NONE = 315,
+     ID = 316,
+     LAB = 317,
+     TYPE = 318,
+     LNG = 319,
+     DBL = 320,
+     CHR = 321,
+     STR = 322,
+     RA = 323,
+     LA = 324,
+     OA = 325,
+     XA = 326,
+     AA = 327,
+     MA = 328,
+     DA = 329,
+     TA = 330,
+     NA = 331,
+     PA = 332,
+     OR = 333,
+     AN = 334,
+     NE = 335,
+     EQ = 336,
+     GE = 337,
+     LE = 338,
+     RS = 339,
+     LS = 340,
+     AR = 341,
+     PP = 342,
+     NN = 343
+   };
+#endif
+/* Tokens.  */
+#define PRAGMA 258
+#define AUTO 259
+#define DOUBLE 260
+#define INT 261
+#define STRUCT 262
+#define BREAK 263
+#define ELSE 264
+#define LONG 265
+#define SWITCH 266
+#define CASE 267
+#define ENUM 268
+#define REGISTER 269
+#define TYPEDEF 270
+#define CHAR 271
+#define EXTERN 272
+#define RETURN 273
+#define UNION 274
+#define CONST 275
+#define FLOAT 276
+#define SHORT 277
+#define UNSIGNED 278
+#define CONTINUE 279
+#define FOR 280
+#define SIGNED 281
+#define VOID 282
+#define DEFAULT 283
+#define GOTO 284
+#define SIZEOF 285
+#define VOLATILE 286
+#define DO 287
+#define IF 288
+#define STATIC 289
+#define WHILE 290
+#define CLASS 291
+#define PRIVATE 292
+#define PROTECTED 293
+#define PUBLIC 294
+#define VIRTUAL 295
+#define INLINE 296
+#define OPERATOR 297
+#define LLONG 298
+#define BOOL 299
+#define CFALSE 300
+#define CTRUE 301
+#define WCHAR 302
+#define TIME 303
+#define USING 304
+#define NAMESPACE 305
+#define ULLONG 306
+#define MUSTUNDERSTAND 307
+#define SIZE 308
+#define FRIEND 309
+#define TEMPLATE 310
+#define EXPLICIT 311
+#define TYPENAME 312
+#define RESTRICT 313
+#define null 314
+#define NONE 315
+#define ID 316
+#define LAB 317
+#define TYPE 318
+#define LNG 319
+#define DBL 320
+#define CHR 321
+#define STR 322
+#define RA 323
+#define LA 324
+#define OA 325
+#define XA 326
+#define AA 327
+#define MA 328
+#define DA 329
+#define TA 330
+#define NA 331
+#define PA 332
+#define OR 333
+#define AN 334
+#define NE 335
+#define EQ 336
+#define GE 337
+#define LE 338
+#define RS 339
+#define LS 340
+#define AR 341
+#define PP 342
+#define NN 343
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 61 "soapcpp2_yacc.y"
+
+
+#include "soapcpp2.h"
+
+#ifdef WIN32
+#ifndef __STDC__
+#define __STDC__
+#endif
+#define YYINCLUDED_STDLIB_H
+#ifdef WIN32_WITHOUT_SOLARIS_FLEX
+extern int soapcpp2lex();
+#else
+extern int yylex();
+#endif
+#else
+extern int yylex();
+#endif
+
+extern int is_XML(Tnode*);
+
+#define MAXNEST 16	/* max. nesting depth of scopes */
+
+struct Scope
+{	Table	*table;
+	Entry	*entry;
+	Node	node;
+	LONG64	val;
+	int	offset;
+	Bool	grow;	/* true if offset grows with declarations */
+	Bool	mask;	/* true if enum is mask */
+}	stack[MAXNEST],	/* stack of tables and offsets */
+	*sp;		/* current scope stack pointer */
+
+Table	*classtable = (Table*)0,
+	*enumtable = (Table*)0,
+	*typetable = (Table*)0,
+	*booltable = (Table*)0,
+	*templatetable = (Table*)0;
+
+char	*namespaceid = NULL;
+int	transient = 0;
+int	permission = 0;
+int	custom_header = 1;
+int	custom_fault = 1;
+Pragma	*pragmas = NULL;
+Tnode	*qname = NULL;
+Tnode	*xml = NULL;
+
+/* function prototypes for support routine section */
+static Entry	*undefined(Symbol*);
+static Tnode	*mgtype(Tnode*, Tnode*);
+static Node	op(const char*, Node, Node), iop(const char*, Node, Node), relop(const char*, Node, Node);
+static void	mkscope(Table*, int), enterscope(Table*, int), exitscope();
+static int	integer(Tnode*), real(Tnode*), numeric(Tnode*);
+static void	add_soap(), add_XML(), add_qname(), add_header(Table*), add_fault(Table*), add_response(Entry*, Entry*), add_result(Tnode*);
+extern char	*c_storage(Storage), *c_type(Tnode*), *c_ident(Tnode*);
+extern int	is_primitive_or_string(Tnode*), is_stdstr(Tnode*), is_binary(Tnode*), is_external(Tnode*), is_mutable(Tnode*);
+
+/* Temporaries used in semantic rules */
+int	i;
+char	*s, *s1, *s2;
+Symbol	*sym;
+Entry	*p, *q;
+Tnode	*t;
+Node	tmp, c;
+Pragma	**pp;
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+#line 135 "soapcpp2_yacc.y"
+{	Symbol	*sym;
+	LONG64	i;
+	double	r;
+	char	c;
+	char	*s;
+	Tnode	*typ;
+	Storage	sto;
+	Node	rec;
+	Entry	*e;
+}
+/* Line 187 of yacc.c.  */
+#line 352 "soapcpp2_yacc.c"
+	YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 216 of yacc.c.  */
+#line 365 "soapcpp2_yacc.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  3
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   1011
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  113
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  61
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  229
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  357
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   343
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,   108,     2,     2,     2,    99,    86,     2,
+     110,   111,    97,    95,    68,    96,     2,    98,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    81,   105,
+      89,    69,    90,    80,   112,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,   106,     2,   107,    85,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,   103,    84,   104,   109,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
+      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
+      65,    66,    67,    70,    71,    72,    73,    74,    75,    76,
+      77,    78,    79,    82,    83,    87,    88,    91,    92,    93,
+      94,   100,   101,   102
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     6,     7,    13,    15,    16,    19,    22,
+      24,    27,    29,    31,    33,    34,    38,    43,    48,    53,
+      58,    60,    62,    63,    64,    65,    67,    70,    74,    77,
+      80,    84,    89,    95,    98,   100,   102,   104,   107,   110,
+     113,   116,   119,   122,   125,   128,   131,   134,   137,   140,
+     143,   146,   149,   152,   155,   158,   161,   164,   167,   170,
+     173,   176,   179,   182,   185,   188,   191,   194,   197,   200,
+     203,   206,   210,   214,   217,   219,   223,   231,   232,   233,
+     235,   237,   241,   248,   249,   251,   255,   260,   261,   264,
+     267,   269,   271,   274,   277,   279,   281,   283,   285,   287,
+     289,   291,   293,   295,   297,   299,   301,   303,   305,   307,
+     315,   321,   327,   335,   337,   341,   347,   353,   356,   359,
+     365,   372,   375,   378,   385,   392,   401,   404,   407,   409,
+     414,   417,   420,   423,   425,   427,   430,   433,   436,   438,
+     441,   442,   443,   444,   445,   447,   448,   450,   452,   454,
+     456,   458,   460,   462,   464,   466,   468,   470,   472,   474,
+     476,   477,   479,   480,   483,   484,   486,   487,   490,   493,
+     494,   499,   503,   505,   506,   509,   511,   514,   518,   523,
+     527,   528,   530,   532,   535,   538,   542,   544,   550,   552,
+     554,   558,   560,   562,   566,   568,   570,   574,   578,   582,
+     586,   590,   594,   598,   602,   606,   610,   614,   618,   622,
+     626,   630,   634,   636,   639,   642,   645,   648,   651,   654,
+     659,   661,   665,   667,   669,   671,   673,   675,   677,   679
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int16 yyrhs[] =
+{
+     114,     0,    -1,   115,   116,    -1,    -1,    50,    61,   103,
+     117,   104,    -1,   117,    -1,    -1,   117,   118,    -1,   126,
+     105,    -1,   119,    -1,     1,   105,    -1,   121,    -1,   122,
+      -1,     3,    -1,    -1,   126,   105,   120,    -1,    37,    81,
+     123,   120,    -1,    38,    81,   124,   120,    -1,    39,    81,
+     125,   120,    -1,   121,   120,   122,   120,    -1,   106,    -1,
+     107,    -1,    -1,    -1,    -1,   140,    -1,   140,   127,    -1,
+     140,   128,   133,    -1,   131,   133,    -1,   132,   133,    -1,
+     126,    68,   127,    -1,   126,    68,   128,   133,    -1,   157,
+      61,   159,   161,   160,    -1,   157,   130,    -1,    61,    -1,
+      63,    -1,    61,    -1,    42,   108,    -1,    42,   109,    -1,
+      42,    69,    -1,    42,    79,    -1,    42,    78,    -1,    42,
+      77,    -1,    42,    76,    -1,    42,    75,    -1,    42,    74,
+      -1,    42,    73,    -1,    42,    72,    -1,    42,    71,    -1,
+      42,    70,    -1,    42,    82,    -1,    42,    83,    -1,    42,
+      84,    -1,    42,    85,    -1,    42,    86,    -1,    42,    88,
+      -1,    42,    87,    -1,    42,    89,    -1,    42,    92,    -1,
+      42,    90,    -1,    42,    91,    -1,    42,    94,    -1,    42,
+      93,    -1,    42,    95,    -1,    42,    96,    -1,    42,    97,
+      -1,    42,    98,    -1,    42,    99,    -1,    42,   101,    -1,
+      42,   102,    -1,    42,   100,    -1,    42,   106,   107,    -1,
+      42,   110,   111,    -1,    42,   139,    -1,    63,    -1,   156,
+     109,    63,    -1,   134,   110,   152,   135,   111,   154,   155,
+      -1,    -1,    -1,   136,    -1,   137,    -1,   137,    68,   136,
+      -1,   141,   157,   138,   159,   161,   160,    -1,    -1,    61,
+      -1,   141,   157,   158,    -1,   141,   157,    61,   158,    -1,
+      -1,   153,   140,    -1,   142,   140,    -1,   153,    -1,   142,
+      -1,   153,   141,    -1,   142,   141,    -1,    27,    -1,    44,
+      -1,    16,    -1,    47,    -1,    22,    -1,     6,    -1,    10,
+      -1,    43,    -1,    51,    -1,    53,    -1,    21,    -1,     5,
+      -1,    26,    -1,    23,    -1,    48,    -1,    55,    89,   146,
+     129,    90,    36,   129,    -1,    36,   103,   148,   120,   104,
+      -1,   144,   103,   148,   120,   104,    -1,   144,    81,   147,
+     103,   148,   120,   104,    -1,   144,    -1,   144,    81,   147,
+      -1,     7,   103,   148,   120,   104,    -1,   143,   103,   148,
+     120,   104,    -1,     7,    61,    -1,     7,    63,    -1,    19,
+     103,   149,   120,   104,    -1,    19,   129,   103,   149,   120,
+     104,    -1,    19,    61,    -1,    19,    63,    -1,    13,   103,
+     148,   126,   151,   104,    -1,   145,   103,   148,   126,   151,
+     104,    -1,    13,    97,   129,   103,   150,   126,   151,   104,
+      -1,    13,    61,    -1,    13,    63,    -1,    63,    -1,    63,
+      89,   139,    90,    -1,     7,   129,    -1,    36,   129,    -1,
+      13,   129,    -1,    36,    -1,    57,    -1,    38,   147,    -1,
+      37,   147,    -1,    39,   147,    -1,    63,    -1,     7,    61,
+      -1,    -1,    -1,    -1,    -1,    68,    -1,    -1,     4,    -1,
+      14,    -1,    34,    -1,    56,    -1,    17,    -1,    15,    -1,
+      40,    -1,    20,    -1,    54,    -1,    41,    -1,    52,    -1,
+      18,    -1,   112,    -1,    31,    -1,    -1,    20,    -1,    -1,
+      69,    64,    -1,    -1,    40,    -1,    -1,   157,    97,    -1,
+     157,    86,    -1,    -1,   106,   165,   107,   158,    -1,   106,
+     107,   158,    -1,   158,    -1,    -1,    69,   165,    -1,   162,
+      -1,   162,   163,    -1,   162,   163,    81,    -1,   162,   163,
+      81,   163,    -1,   162,    81,   163,    -1,    -1,    67,    -1,
+      64,    -1,    95,    64,    -1,    96,    64,    -1,   164,    68,
+     164,    -1,   165,    -1,   168,    80,   166,    81,   165,    -1,
+     167,    -1,   164,    -1,   168,    82,   169,    -1,   169,    -1,
+     167,    -1,   170,    83,   171,    -1,   171,    -1,   169,    -1,
+     171,    84,   171,    -1,   171,    85,   171,    -1,   171,    86,
+     171,    -1,   171,    88,   171,    -1,   171,    87,   171,    -1,
+     171,    89,   171,    -1,   171,    92,   171,    -1,   171,    90,
+     171,    -1,   171,    91,   171,    -1,   171,    94,   171,    -1,
+     171,    93,   171,    -1,   171,    95,   171,    -1,   171,    96,
+     171,    -1,   171,    97,   171,    -1,   171,    98,   171,    -1,
+     171,    99,   171,    -1,   172,    -1,   108,   172,    -1,   109,
+     172,    -1,    96,   172,    -1,    95,   172,    -1,    97,   172,
+      -1,    86,   172,    -1,    30,   110,   139,   111,    -1,   173,
+      -1,   110,   164,   111,    -1,    61,    -1,    64,    -1,    59,
+      -1,    65,    -1,    66,    -1,    67,    -1,    45,    -1,    46,
+      -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   208,   208,   224,   238,   240,   242,   248,   250,   251,
+     252,   259,   260,   262,   285,   288,   290,   292,   294,   296,
+     299,   302,   305,   308,   311,   314,   315,   316,   318,   319,
+     320,   321,   324,   431,   447,   448,   450,   451,   452,   453,
+     454,   455,   456,   457,   458,   459,   460,   461,   462,   463,
+     464,   465,   466,   467,   468,   469,   470,   471,   472,   473,
+     474,   475,   476,   477,   478,   479,   480,   481,   482,   483,
+     484,   485,   486,   487,   498,   508,   525,   583,   585,   586,
+     588,   589,   591,   670,   677,   692,   694,   697,   701,   711,
+     758,   764,   768,   778,   825,   826,   827,   828,   829,   830,
+     831,   832,   833,   834,   835,   836,   837,   838,   839,   840,
+     848,   870,   881,   900,   903,   916,   938,   957,   972,   987,
+    1010,  1030,  1045,  1060,  1082,  1101,  1120,  1128,  1136,  1154,
+    1164,  1181,  1200,  1217,  1218,  1220,  1221,  1222,  1223,  1230,
+    1232,  1239,  1247,  1253,  1254,  1256,  1264,  1265,  1266,  1267,
+    1268,  1269,  1270,  1271,  1272,  1273,  1274,  1275,  1276,  1280,
+    1282,  1283,  1285,  1286,  1288,  1289,  1291,  1292,  1299,  1304,
+    1306,  1319,  1323,  1331,  1332,  1343,  1348,  1353,  1358,  1363,
+    1369,  1370,  1372,  1373,  1374,  1383,  1384,  1387,  1392,  1395,
+    1398,  1401,  1403,  1406,  1409,  1411,  1414,  1415,  1416,  1417,
+    1418,  1419,  1420,  1421,  1422,  1423,  1424,  1425,  1426,  1427,
+    1428,  1429,  1430,  1433,  1438,  1443,  1453,  1454,  1461,  1465,
+    1470,  1473,  1474,  1481,  1485,  1489,  1493,  1497,  1501,  1505
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "PRAGMA", "AUTO", "DOUBLE", "INT",
+  "STRUCT", "BREAK", "ELSE", "LONG", "SWITCH", "CASE", "ENUM", "REGISTER",
+  "TYPEDEF", "CHAR", "EXTERN", "RETURN", "UNION", "CONST", "FLOAT",
+  "SHORT", "UNSIGNED", "CONTINUE", "FOR", "SIGNED", "VOID", "DEFAULT",
+  "GOTO", "SIZEOF", "VOLATILE", "DO", "IF", "STATIC", "WHILE", "CLASS",
+  "PRIVATE", "PROTECTED", "PUBLIC", "VIRTUAL", "INLINE", "OPERATOR",
+  "LLONG", "BOOL", "CFALSE", "CTRUE", "WCHAR", "TIME", "USING",
+  "NAMESPACE", "ULLONG", "MUSTUNDERSTAND", "SIZE", "FRIEND", "TEMPLATE",
+  "EXPLICIT", "TYPENAME", "RESTRICT", "null", "NONE", "ID", "LAB", "TYPE",
+  "LNG", "DBL", "CHR", "STR", "','", "'='", "RA", "LA", "OA", "XA", "AA",
+  "MA", "DA", "TA", "NA", "PA", "'?'", "':'", "OR", "AN", "'|'", "'^'",
+  "'&'", "NE", "EQ", "'<'", "'>'", "GE", "LE", "RS", "LS", "'+'", "'-'",
+  "'*'", "'/'", "'%'", "AR", "PP", "NN", "'{'", "'}'", "';'", "'['", "']'",
+  "'!'", "'~'", "'('", "')'", "'@'", "$accept", "prog", "s1", "exts",
+  "exts1", "ext", "pragma", "decls", "t1", "t2", "t3", "t4", "t5", "dclrs",
+  "dclr", "fdclr", "id", "name", "constr", "destr", "func", "fname",
+  "fargso", "fargs", "farg", "arg", "texp", "spec", "tspec", "type",
+  "struct", "class", "enum", "tname", "base", "s2", "s3", "s4", "s5", "s6",
+  "store", "constobj", "abstract", "virtual", "ptrs", "array", "arrayck",
+  "init", "occurs", "patt", "cint", "expr", "cexp", "qexp", "oexp", "obex",
+  "aexp", "abex", "rexp", "lexp", "pexp", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
+     305,   306,   307,   308,   309,   310,   311,   312,   313,   314,
+     315,   316,   317,   318,   319,   320,   321,   322,    44,    61,
+     323,   324,   325,   326,   327,   328,   329,   330,   331,   332,
+      63,    58,   333,   334,   124,    94,    38,   335,   336,    60,
+      62,   337,   338,   339,   340,    43,    45,    42,    47,    37,
+     341,   342,   343,   123,   125,    59,    91,    93,    33,   126,
+      40,    41,    64
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,   113,   114,   115,   116,   116,   117,   117,   118,   118,
+     118,   118,   118,   119,   120,   120,   120,   120,   120,   120,
+     121,   122,   123,   124,   125,   126,   126,   126,   126,   126,
+     126,   126,   127,   128,   129,   129,   130,   130,   130,   130,
+     130,   130,   130,   130,   130,   130,   130,   130,   130,   130,
+     130,   130,   130,   130,   130,   130,   130,   130,   130,   130,
+     130,   130,   130,   130,   130,   130,   130,   130,   130,   130,
+     130,   130,   130,   130,   131,   132,   133,   134,   135,   135,
+     136,   136,   137,   138,   138,   139,   139,   140,   140,   140,
+     141,   141,   141,   141,   142,   142,   142,   142,   142,   142,
+     142,   142,   142,   142,   142,   142,   142,   142,   142,   142,
+     142,   142,   142,   142,   142,   142,   142,   142,   142,   142,
+     142,   142,   142,   142,   142,   142,   142,   142,   142,   142,
+     143,   144,   145,   146,   146,   147,   147,   147,   147,   147,
+     148,   149,   150,   151,   151,   152,   153,   153,   153,   153,
+     153,   153,   153,   153,   153,   153,   153,   153,   153,   153,
+     154,   154,   155,   155,   156,   156,   157,   157,   157,   158,
+     158,   158,   159,   160,   160,   161,   161,   161,   161,   161,
+     162,   162,   163,   163,   163,   164,   164,   165,   165,   166,
+     167,   167,   168,   169,   169,   170,   171,   171,   171,   171,
+     171,   171,   171,   171,   171,   171,   171,   171,   171,   171,
+     171,   171,   171,   172,   172,   172,   172,   172,   172,   172,
+     172,   173,   173,   173,   173,   173,   173,   173,   173,   173
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     2,     0,     5,     1,     0,     2,     2,     1,
+       2,     1,     1,     1,     0,     3,     4,     4,     4,     4,
+       1,     1,     0,     0,     0,     1,     2,     3,     2,     2,
+       3,     4,     5,     2,     1,     1,     1,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     3,     3,     2,     1,     3,     7,     0,     0,     1,
+       1,     3,     6,     0,     1,     3,     4,     0,     2,     2,
+       1,     1,     2,     2,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     7,
+       5,     5,     7,     1,     3,     5,     5,     2,     2,     5,
+       6,     2,     2,     6,     6,     8,     2,     2,     1,     4,
+       2,     2,     2,     1,     1,     2,     2,     2,     1,     2,
+       0,     0,     0,     0,     1,     0,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       0,     1,     0,     2,     0,     1,     0,     2,     2,     0,
+       4,     3,     1,     0,     2,     1,     2,     3,     4,     3,
+       0,     1,     1,     2,     2,     3,     1,     5,     1,     1,
+       3,     1,     1,     3,     1,     1,     3,     3,     3,     3,
+       3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
+       3,     3,     1,     2,     2,     2,     2,     2,     2,     4,
+       1,     3,     1,     1,     1,     1,     1,     1,     1,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       3,     0,     6,     1,     0,     2,     0,     0,     0,    13,
+     146,   105,    99,     0,   100,     0,   147,   151,    96,   150,
+     157,     0,   153,   104,    98,   107,   106,    94,   159,   148,
+       0,   152,   155,   101,    95,    97,   108,   102,   156,   103,
+     154,     0,   149,   128,    20,    21,   158,     7,     9,    11,
+      12,     0,    77,    77,   166,    87,     0,   113,     0,    87,
+       0,     6,    10,   117,   118,   140,   130,   126,   127,     0,
+     140,   132,   121,   122,   141,     0,    34,    35,   140,   131,
+       0,     0,   166,     8,    28,     0,    29,    26,    77,     0,
+     152,   128,    89,   140,     0,   140,   140,    88,     0,     0,
+      87,     0,    87,    87,   141,    87,   133,   134,     0,     0,
+     166,    91,    90,    30,    77,   145,    27,     0,   169,   168,
+     167,    33,    87,     0,     0,     0,     0,   138,   114,    87,
+      87,    75,     4,     0,     0,     0,     0,    87,     0,   142,
+     143,     0,    87,     0,     0,   129,   169,    93,    92,    31,
+      78,    39,    49,    48,    47,    46,    45,    44,    43,    42,
+      41,    40,    50,    51,    52,    53,    54,    56,    55,    57,
+      59,    60,    58,    62,    61,    63,    64,    65,    66,    67,
+      70,    68,    69,     0,    37,    38,     0,    73,     0,   172,
+     180,     0,   139,   136,   135,   137,   140,     0,   143,    22,
+      23,    24,   115,     0,    87,    87,   166,     0,   119,     0,
+     110,     0,   169,    85,     0,    79,    80,   166,    71,    72,
+       0,   228,   229,   224,   222,   223,   225,   226,   227,     0,
+       0,     0,     0,   169,     0,     0,     0,     0,   188,     0,
+     191,     0,   194,   212,   220,   181,   173,   175,   116,    87,
+     111,     0,    87,    87,    87,    87,    15,   143,   123,   120,
+       0,    86,   160,     0,    83,     0,   218,   216,   215,   217,
+     171,   213,   214,     0,   186,   169,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    32,   182,     0,     0,
+       0,   176,     0,   124,    16,    17,    18,    19,     0,   109,
+     161,   162,    81,    84,   169,     0,     0,   221,   170,   189,
+       0,   190,   193,   196,   197,   198,   200,   199,   201,   203,
+     204,   202,   206,   205,   207,   208,   209,   210,   211,   174,
+     179,   183,   184,   177,   112,   125,     0,    76,   180,   219,
+     185,     0,   178,   163,   173,   187,    82
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     1,     2,     5,     6,    47,    48,   136,   137,    50,
+     252,   253,   254,   138,   113,   114,    66,   121,    52,    53,
+      84,    85,   214,   215,   216,   314,   109,    54,   110,    55,
+      56,    57,    58,   108,   128,   100,   103,   205,   207,   150,
+      59,   311,   347,    60,    89,   189,   190,   296,   246,   247,
+     301,   273,   274,   320,   238,   239,   240,   241,   242,   243,
+     244
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -283
+static const yytype_int16 yypact[] =
+{
+    -283,    20,   -29,  -283,   -30,  -283,   206,   -14,    -7,  -283,
+    -283,  -283,  -283,    -3,  -283,     2,  -283,  -283,  -283,  -283,
+    -283,     9,  -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,
+      29,    -8,  -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,
+    -283,    45,  -283,    14,  -283,  -283,  -283,  -283,  -283,  -283,
+    -283,     8,  -283,  -283,    15,   889,    36,    30,    50,   889,
+      46,  -283,  -283,    53,    58,  -283,  -283,    53,    58,   -17,
+    -283,  -283,    53,    58,  -283,    59,  -283,  -283,  -283,  -283,
+      79,   889,  -283,  -283,  -283,    54,  -283,  -283,  -283,   -18,
+    -283,    76,  -283,  -283,    18,  -283,  -283,  -283,   122,   316,
+     643,    85,   826,   643,  -283,   643,  -283,  -283,   -17,   118,
+    -283,   889,   889,  -283,  -283,  -283,  -283,   425,   -80,  -283,
+    -283,  -283,   643,   153,    18,    18,    18,  -283,   112,   643,
+     826,  -283,  -283,   136,   137,   149,   127,   752,    16,  -283,
+     170,   135,   643,   139,   151,  -283,   -33,  -283,  -283,  -283,
+     889,  -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,
+    -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,
+    -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,
+    -283,  -283,  -283,   144,  -283,  -283,   133,  -283,    21,  -283,
+     185,   152,  -283,  -283,  -283,  -283,  -283,   159,   170,  -283,
+    -283,  -283,  -283,   148,   534,   826,   160,   161,  -283,   162,
+    -283,   232,   164,  -283,   180,  -283,   203,  -283,  -283,  -283,
+     163,  -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,   901,
+     901,   901,   901,   164,   901,   901,   901,   165,    22,    55,
+     214,   217,   191,  -283,  -283,  -283,   233,    27,  -283,   643,
+    -283,   197,   534,   534,   534,   534,  -283,   170,  -283,  -283,
+     -17,  -283,   284,   889,   -38,   889,  -283,  -283,  -283,  -283,
+    -283,  -283,  -283,   -49,  -283,   164,   901,   901,   901,   901,
+     901,   901,   901,   901,   901,   901,   901,   901,   901,   901,
+     901,   901,   901,   901,   901,   901,  -283,  -283,    31,   241,
+     242,   226,   204,  -283,  -283,  -283,  -283,  -283,   205,  -283,
+    -283,   245,  -283,  -283,   164,   199,   901,  -283,  -283,   248,
+     243,   214,   191,   300,   512,   525,    52,    52,    97,    97,
+      97,    97,   106,   106,   100,   100,  -283,  -283,  -283,  -283,
+    -283,  -283,  -283,    31,  -283,  -283,   261,  -283,   185,  -283,
+    -283,   901,  -283,  -283,   233,  -283,  -283
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+    -283,  -283,  -283,  -283,   266,  -283,  -283,   -95,     7,   125,
+    -283,  -283,  -283,    -5,   286,   287,   -15,  -283,  -283,  -283,
+     -36,  -283,  -283,    81,  -283,  -283,  -113,   -10,  -100,   -79,
+    -283,  -283,  -283,  -283,   110,   -56,   244,  -283,  -180,  -283,
+     -76,  -283,  -283,  -283,  -103,  -137,    32,    -9,     1,  -283,
+    -282,  -247,  -185,  -283,  -283,  -283,    74,  -283,  -111,    64,
+    -283
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -196
+static const yytype_int16 yytable[] =
+{
+      71,    51,   111,   237,   187,   112,    75,   146,   141,   213,
+     143,   147,   148,    49,   102,    79,   340,    86,   251,   316,
+       3,     4,   105,   313,   117,   123,   188,   191,   212,   319,
+     -36,     7,   111,   111,   197,   112,   112,   122,   111,   129,
+     130,   112,   203,   118,    76,    92,    77,   209,   119,    97,
+     217,   220,   116,   119,   101,   124,   125,   126,    63,   120,
+      64,   352,   317,    67,   120,    68,   221,   222,   119,   350,
+      72,   111,    73,   188,   112,   261,    82,   308,   149,   120,
+     223,   127,   224,   -25,    82,   225,   226,   227,   228,    61,
+      76,   297,    77,   144,    51,   297,   270,   140,    62,    69,
+      65,  -165,  -192,    81,  -192,    70,    49,   229,   298,   256,
+     339,    94,    74,    83,   264,   106,   230,   231,   232,   -25,
+     -25,   204,   299,   300,   -74,   198,   299,   300,   233,   234,
+     235,   236,    78,    95,    80,   276,   107,   277,   318,    93,
+     249,   284,   285,   286,   287,   288,   289,   290,   291,   292,
+     293,   294,   315,    96,   302,    98,   -34,   304,   305,   306,
+     307,   -35,   104,   217,   115,    81,   355,   322,   323,   324,
+     325,   326,   327,   328,   329,   330,   331,   332,   333,   334,
+     335,   336,   337,   338,   111,   131,   111,   112,   139,   112,
+     288,   289,   290,   291,   292,   293,   294,   292,   293,   294,
+     257,   290,   291,   292,   293,   294,    -5,     8,   145,     9,
+      10,    11,    12,    13,   192,   196,    14,   199,   200,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+     201,   202,    26,    27,   193,   194,   195,    28,   206,   208,
+      29,   211,    30,   210,   219,   309,    31,    32,   -87,    33,
+      34,   218,   245,    35,    36,    45,   248,    37,    38,    39,
+      40,    41,    42,   250,  -144,   258,   259,   -87,   260,    43,
+     188,   263,   275,   265,   -87,   279,   280,   281,   282,   283,
+     284,   285,   286,   287,   288,   289,   290,   291,   292,   293,
+     294,   262,   -87,   266,   267,   268,   269,  -195,   271,   272,
+     278,   303,   295,   -87,   310,   341,   342,   343,   344,   345,
+     349,   -87,    44,    45,   346,  -164,   316,     8,    46,     9,
+      10,    11,    12,    13,   351,   353,    14,    99,   255,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      87,    88,    26,    27,   312,   356,   348,    28,   142,   354,
+      29,   321,    30,     0,     0,     0,    31,    32,   -87,    33,
+      34,     0,     0,    35,    36,     0,     0,    37,    38,    39,
+      40,    41,    42,     0,     0,     0,     0,   -87,     0,    43,
+       0,     0,     0,     0,   -87,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+       0,     0,   -87,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,   -87,     0,     0,     0,     0,     0,     0,
+     132,   -87,    44,    45,     0,  -164,     0,     0,    46,    10,
+      11,    12,    13,     0,     0,    14,     0,     0,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,    24,    25,     0,
+       0,    26,    27,     0,     0,     0,    28,     0,     0,    29,
+       0,    30,     0,     0,     0,    90,    32,     0,    33,    34,
+       0,     0,    35,    36,     0,     0,    37,    38,    39,    40,
+      41,    42,     0,     0,     0,     0,     0,     0,    91,     0,
+       0,     0,     0,     0,   151,   152,   153,   154,   155,   156,
+     157,   158,   159,   160,   161,     0,     0,   162,   163,   164,
+     165,   166,   167,   168,   169,   170,   171,   172,   173,   174,
+     175,   176,   177,   178,   179,   180,   181,   182,     0,     0,
+       0,   183,     0,   184,   185,   186,     0,    46,    10,    11,
+      12,    13,     0,     0,    14,     0,     0,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    24,    25,     0,     0,
+      26,    27,     0,     0,     0,    28,     0,     0,    29,     0,
+      30,   133,   134,   135,    31,    32,     0,    33,    34,     0,
+       0,    35,    36,     0,     0,    37,    38,    39,    40,    41,
+      42,     0,     0,     0,     0,     0,     0,    43,   281,   282,
+     283,   284,   285,   286,   287,   288,   289,   290,   291,   292,
+     293,   294,   282,   283,   284,   285,   286,   287,   288,   289,
+     290,   291,   292,   293,   294,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,   -14,     0,
+      44,   -14,     0,  -164,     0,     0,    46,    10,    11,    12,
+      13,     0,     0,    14,     0,     0,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    24,    25,     0,     0,    26,
+      27,     0,     0,     0,    28,     0,     0,    29,     0,    30,
+     133,   134,   135,    31,    32,     0,    33,    34,     0,     0,
+      35,    36,     0,     0,    37,    38,    39,    40,    41,    42,
+       0,     0,     0,     0,     0,     0,    43,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,   -14,     0,    44,
+       0,     0,  -164,     0,     0,    46,    10,    11,    12,    13,
+       0,     0,    14,     0,     0,    15,    16,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,     0,     0,    26,    27,
+       0,     0,     0,    28,     0,     0,    29,     0,    30,   133,
+     134,   135,    31,    32,     0,    33,    34,     0,     0,    35,
+      36,     0,     0,    37,    38,    39,    40,    41,    42,     0,
+       0,     0,     0,     0,     0,    43,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      10,    11,    12,    13,     0,     0,    14,     0,     0,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+       0,     0,    26,    27,     0,     0,     0,    28,    44,   -14,
+      29,  -164,    30,     0,    46,     0,    31,    32,     0,    33,
+      34,     0,     0,    35,    36,     0,     0,    37,    38,    39,
+      40,    41,    42,     0,     0,     0,     0,     0,     0,    43,
+       0,     0,     0,    10,    11,    12,    13,     0,     0,    14,
+       0,     0,    15,    16,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,     0,     0,    26,    27,     0,     0,     0,
+      28,     0,     0,    29,     0,    30,     0,     0,     0,    90,
+      32,   220,    33,    34,     0,  -164,    35,    36,    46,     0,
+      37,    38,    39,    40,    41,    42,   221,   222,     0,     0,
+       0,     0,    91,     0,     0,     0,     0,     0,     0,     0,
+     223,     0,   224,     0,     0,   225,   226,   227,   228,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,   229,     0,     0,
+       0,     0,     0,     0,     0,     0,   230,   231,   232,     0,
+       0,    46,     0,     0,     0,     0,     0,     0,     0,   234,
+     235,   236
+};
+
+static const yytype_int16 yycheck[] =
+{
+      15,     6,    81,   188,   117,    81,    21,   110,   103,   146,
+     105,   111,   112,     6,    70,    30,   298,    53,   198,    68,
+       0,    50,    78,    61,    42,     7,   106,   122,    61,   276,
+     110,    61,   111,   112,   129,   111,   112,    93,   117,    95,
+      96,   117,   137,    61,    61,    55,    63,   142,    86,    59,
+     150,    30,    88,    86,    69,    37,    38,    39,    61,    97,
+      63,   343,   111,    61,    97,    63,    45,    46,    86,   316,
+      61,   150,    63,   106,   150,   212,    68,   257,   114,    97,
+      59,    63,    61,    68,    68,    64,    65,    66,    67,   103,
+      61,    64,    63,   108,    99,    64,   233,   102,   105,    97,
+     103,   109,    80,    89,    82,   103,    99,    86,    81,   204,
+     295,    81,   103,   105,   217,    36,    95,    96,    97,   104,
+     105,   105,    95,    96,   110,   130,    95,    96,   107,   108,
+     109,   110,   103,   103,    89,    80,    57,    82,   275,   103,
+     196,    89,    90,    91,    92,    93,    94,    95,    96,    97,
+      98,    99,   265,   103,   249,   109,   103,   252,   253,   254,
+     255,   103,   103,   263,   110,    89,   351,   278,   279,   280,
+     281,   282,   283,   284,   285,   286,   287,   288,   289,   290,
+     291,   292,   293,   294,   263,    63,   265,   263,   103,   265,
+      93,    94,    95,    96,    97,    98,    99,    97,    98,    99,
+     205,    95,    96,    97,    98,    99,     0,     1,    90,     3,
+       4,     5,     6,     7,    61,   103,    10,    81,    81,    13,
+      14,    15,    16,    17,    18,    19,    20,    21,    22,    23,
+      81,   104,    26,    27,   124,   125,   126,    31,    68,   104,
+      34,    90,    36,   104,   111,   260,    40,    41,    42,    43,
+      44,   107,    67,    47,    48,   107,   104,    51,    52,    53,
+      54,    55,    56,   104,   104,   104,   104,    61,    36,    63,
+     106,    68,   107,   110,    68,    84,    85,    86,    87,    88,
+      89,    90,    91,    92,    93,    94,    95,    96,    97,    98,
+      99,   111,    86,   229,   230,   231,   232,    83,   234,   235,
+      83,   104,    69,    97,    20,    64,    64,    81,   104,   104,
+     111,   105,   106,   107,    69,   109,    68,     1,   112,     3,
+       4,     5,     6,     7,    81,    64,    10,    61,   203,    13,
+      14,    15,    16,    17,    18,    19,    20,    21,    22,    23,
+      54,    54,    26,    27,   263,   354,   314,    31,   104,   348,
+      34,   277,    36,    -1,    -1,    -1,    40,    41,    42,    43,
+      44,    -1,    -1,    47,    48,    -1,    -1,    51,    52,    53,
+      54,    55,    56,    -1,    -1,    -1,    -1,    61,    -1,    63,
+      -1,    -1,    -1,    -1,    68,    85,    86,    87,    88,    89,
+      90,    91,    92,    93,    94,    95,    96,    97,    98,    99,
+      -1,    -1,    86,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    97,    -1,    -1,    -1,    -1,    -1,    -1,
+     104,   105,   106,   107,    -1,   109,    -1,    -1,   112,     4,
+       5,     6,     7,    -1,    -1,    10,    -1,    -1,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    -1,
+      -1,    26,    27,    -1,    -1,    -1,    31,    -1,    -1,    34,
+      -1,    36,    -1,    -1,    -1,    40,    41,    -1,    43,    44,
+      -1,    -1,    47,    48,    -1,    -1,    51,    52,    53,    54,
+      55,    56,    -1,    -1,    -1,    -1,    -1,    -1,    63,    -1,
+      -1,    -1,    -1,    -1,    69,    70,    71,    72,    73,    74,
+      75,    76,    77,    78,    79,    -1,    -1,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,    97,    98,    99,   100,   101,   102,    -1,    -1,
+      -1,   106,    -1,   108,   109,   110,    -1,   112,     4,     5,
+       6,     7,    -1,    -1,    10,    -1,    -1,    13,    14,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    -1,    -1,
+      26,    27,    -1,    -1,    -1,    31,    -1,    -1,    34,    -1,
+      36,    37,    38,    39,    40,    41,    -1,    43,    44,    -1,
+      -1,    47,    48,    -1,    -1,    51,    52,    53,    54,    55,
+      56,    -1,    -1,    -1,    -1,    -1,    -1,    63,    86,    87,
+      88,    89,    90,    91,    92,    93,    94,    95,    96,    97,
+      98,    99,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,    97,    98,    99,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   104,    -1,
+     106,   107,    -1,   109,    -1,    -1,   112,     4,     5,     6,
+       7,    -1,    -1,    10,    -1,    -1,    13,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,    -1,    -1,    26,
+      27,    -1,    -1,    -1,    31,    -1,    -1,    34,    -1,    36,
+      37,    38,    39,    40,    41,    -1,    43,    44,    -1,    -1,
+      47,    48,    -1,    -1,    51,    52,    53,    54,    55,    56,
+      -1,    -1,    -1,    -1,    -1,    -1,    63,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,   104,    -1,   106,
+      -1,    -1,   109,    -1,    -1,   112,     4,     5,     6,     7,
+      -1,    -1,    10,    -1,    -1,    13,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    -1,    -1,    26,    27,
+      -1,    -1,    -1,    31,    -1,    -1,    34,    -1,    36,    37,
+      38,    39,    40,    41,    -1,    43,    44,    -1,    -1,    47,
+      48,    -1,    -1,    51,    52,    53,    54,    55,    56,    -1,
+      -1,    -1,    -1,    -1,    -1,    63,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+       4,     5,     6,     7,    -1,    -1,    10,    -1,    -1,    13,
+      14,    15,    16,    17,    18,    19,    20,    21,    22,    23,
+      -1,    -1,    26,    27,    -1,    -1,    -1,    31,   106,   107,
+      34,   109,    36,    -1,   112,    -1,    40,    41,    -1,    43,
+      44,    -1,    -1,    47,    48,    -1,    -1,    51,    52,    53,
+      54,    55,    56,    -1,    -1,    -1,    -1,    -1,    -1,    63,
+      -1,    -1,    -1,     4,     5,     6,     7,    -1,    -1,    10,
+      -1,    -1,    13,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,    -1,    -1,    26,    27,    -1,    -1,    -1,
+      31,    -1,    -1,    34,    -1,    36,    -1,    -1,    -1,    40,
+      41,    30,    43,    44,    -1,   109,    47,    48,   112,    -1,
+      51,    52,    53,    54,    55,    56,    45,    46,    -1,    -1,
+      -1,    -1,    63,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      59,    -1,    61,    -1,    -1,    64,    65,    66,    67,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    86,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    95,    96,    97,    -1,
+      -1,   112,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   108,
+     109,   110
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,   114,   115,     0,    50,   116,   117,    61,     1,     3,
+       4,     5,     6,     7,    10,    13,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    26,    27,    31,    34,
+      36,    40,    41,    43,    44,    47,    48,    51,    52,    53,
+      54,    55,    56,    63,   106,   107,   112,   118,   119,   121,
+     122,   126,   131,   132,   140,   142,   143,   144,   145,   153,
+     156,   103,   105,    61,    63,   103,   129,    61,    63,    97,
+     103,   129,    61,    63,   103,   129,    61,    63,   103,   129,
+      89,    89,    68,   105,   133,   134,   133,   127,   128,   157,
+      40,    63,   140,   103,    81,   103,   103,   140,   109,   117,
+     148,   129,   148,   149,   103,   148,    36,    57,   146,   139,
+     141,   142,   153,   127,   128,   110,   133,    42,    61,    86,
+      97,   130,   148,     7,    37,    38,    39,    63,   147,   148,
+     148,    63,   104,    37,    38,    39,   120,   121,   126,   103,
+     126,   120,   149,   120,   129,    90,   157,   141,   141,   133,
+     152,    69,    70,    71,    72,    73,    74,    75,    76,    77,
+      78,    79,    82,    83,    84,    85,    86,    87,    88,    89,
+      90,    91,    92,    93,    94,    95,    96,    97,    98,    99,
+     100,   101,   102,   106,   108,   109,   110,   139,   106,   158,
+     159,   120,    61,   147,   147,   147,   103,   120,   126,    81,
+      81,    81,   104,   120,   105,   150,    68,   151,   104,   120,
+     104,    90,    61,   158,   135,   136,   137,   141,   107,   111,
+      30,    45,    46,    59,    61,    64,    65,    66,    67,    86,
+      95,    96,    97,   107,   108,   109,   110,   165,   167,   168,
+     169,   170,   171,   172,   173,    67,   161,   162,   104,   148,
+     104,   151,   123,   124,   125,   122,   120,   126,   104,   104,
+      36,   158,   111,    68,   157,   110,   172,   172,   172,   172,
+     158,   172,   172,   164,   165,   107,    80,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,    97,    98,    99,    69,   160,    64,    81,    95,
+      96,   163,   120,   104,   120,   120,   120,   120,   151,   129,
+      20,   154,   136,    61,   138,   139,    68,   111,   158,   164,
+     166,   169,   171,   171,   171,   171,   171,   171,   171,   171,
+     171,   171,   171,   171,   171,   171,   171,   171,   171,   165,
+     163,    64,    64,    81,   104,   104,    69,   155,   159,   111,
+     164,    81,   163,    64,   161,   165,   160
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    yytype_int16 *bottom;
+    yytype_int16 *top;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+
+/* The look-ahead symbol.  */
+int yychar;
+
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+  
+  int yystate;
+  int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to look-ahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a look-ahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+#line 208 "soapcpp2_yacc.y"
+    { if (lflag)
+    			  {	custom_header = 0;
+    			  	custom_fault = 0;
+			  }
+			  else
+			  {	add_header(sp->table);
+			  	add_fault(sp->table);
+			  }
+			  compile(sp->table);
+			  freetable(classtable);
+			  freetable(enumtable);
+			  freetable(typetable);
+			  freetable(booltable);
+			  freetable(templatetable);
+			}
+    break;
+
+  case 3:
+#line 224 "soapcpp2_yacc.y"
+    { classtable = mktable((Table*)0);
+			  enumtable = mktable((Table*)0);
+			  typetable = mktable((Table*)0);
+			  booltable = mktable((Table*)0);
+			  templatetable = mktable((Table*)0);
+			  p = enter(booltable, lookup("false"));
+			  p->info.typ = mkint();
+			  p->info.val.i = 0;
+			  p = enter(booltable, lookup("true"));
+			  p->info.typ = mkint();
+			  p->info.val.i = 1;
+			  mkscope(mktable(mktable((Table*)0)), 0);
+			}
+    break;
+
+  case 4:
+#line 239 "soapcpp2_yacc.y"
+    { namespaceid = (yyvsp[(2) - (5)].sym)->name; }
+    break;
+
+  case 5:
+#line 240 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 6:
+#line 242 "soapcpp2_yacc.y"
+    { add_soap();
+			  if (!lflag)
+			  {	add_qname();
+			  	add_XML();
+			  }
+			}
+    break;
+
+  case 7:
+#line 248 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 8:
+#line 250 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 9:
+#line 251 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 10:
+#line 252 "soapcpp2_yacc.y"
+    { synerror("input before ; skipped");
+			  while (sp > stack)
+			  {	freetable(sp->table);
+			  	exitscope();
+			  }
+			  yyerrok;
+			}
+    break;
+
+  case 11:
+#line 259 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 12:
+#line 260 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 13:
+#line 262 "soapcpp2_yacc.y"
+    { if ((yyvsp[(1) - (1)].s)[1] >= 'a' && (yyvsp[(1) - (1)].s)[1] <= 'z')
+			  {	for (pp = &pragmas; *pp; pp = &(*pp)->next)
+			          ;
+				*pp = (Pragma*)emalloc(sizeof(Pragma));
+				(*pp)->pragma = (char*)emalloc(strlen((yyvsp[(1) - (1)].s))+1);
+				strcpy((*pp)->pragma, (yyvsp[(1) - (1)].s));
+				(*pp)->next = NULL;
+			  }
+			  else if ((i = atoi((yyvsp[(1) - (1)].s)+2)) > 0)
+				yylineno = i;
+			  else
+			  {	sprintf(errbuf, "directive '%s' ignored (use #import to import files and/or use option -i)", (yyvsp[(1) - (1)].s));
+			  	semwarn(errbuf);
+			  }
+			}
+    break;
+
+  case 14:
+#line 285 "soapcpp2_yacc.y"
+    { transient &= ~6;
+			  permission = 0;
+			}
+    break;
+
+  case 15:
+#line 289 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 16:
+#line 291 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 17:
+#line 293 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 18:
+#line 295 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 19:
+#line 297 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 20:
+#line 299 "soapcpp2_yacc.y"
+    { transient |= 1;
+			}
+    break;
+
+  case 21:
+#line 302 "soapcpp2_yacc.y"
+    { transient &= ~1;
+			}
+    break;
+
+  case 22:
+#line 305 "soapcpp2_yacc.y"
+    { permission = Sprivate;
+			}
+    break;
+
+  case 23:
+#line 308 "soapcpp2_yacc.y"
+    { permission = Sprotected;
+			}
+    break;
+
+  case 24:
+#line 311 "soapcpp2_yacc.y"
+    { permission = 0;
+			}
+    break;
+
+  case 25:
+#line 314 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 26:
+#line 315 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 27:
+#line 317 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 28:
+#line 318 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 29:
+#line 319 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 30:
+#line 320 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 31:
+#line 322 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 32:
+#line 325 "soapcpp2_yacc.y"
+    { if (((yyvsp[(3) - (5)].rec).sto & Stypedef) && sp->table->level == GLOBAL)
+			  {	if (((yyvsp[(3) - (5)].rec).typ->type != Tstruct && (yyvsp[(3) - (5)].rec).typ->type != Tunion && (yyvsp[(3) - (5)].rec).typ->type != Tenum) || strcmp((yyvsp[(2) - (5)].sym)->name, (yyvsp[(3) - (5)].rec).typ->id->name))
+				{	p = enter(typetable, (yyvsp[(2) - (5)].sym));
+					p->info.typ = mksymtype((yyvsp[(3) - (5)].rec).typ, (yyvsp[(2) - (5)].sym));
+			  		if ((yyvsp[(3) - (5)].rec).sto & Sextern)
+						p->info.typ->transient = -1;
+					else
+						p->info.typ->transient = (yyvsp[(3) - (5)].rec).typ->transient;
+			  		p->info.sto = (yyvsp[(3) - (5)].rec).sto;
+					p->info.typ->pattern = (yyvsp[(4) - (5)].rec).pattern;
+					if ((yyvsp[(4) - (5)].rec).minOccurs != -1)
+					{	p->info.typ->minLength = (yyvsp[(4) - (5)].rec).minOccurs;
+					}
+					if ((yyvsp[(4) - (5)].rec).maxOccurs > 1)
+						p->info.typ->maxLength = (yyvsp[(4) - (5)].rec).maxOccurs;
+				}
+				(yyvsp[(2) - (5)].sym)->token = TYPE;
+			  }
+			  else
+			  {	p = enter(sp->table, (yyvsp[(2) - (5)].sym));
+			  	p->info.typ = (yyvsp[(3) - (5)].rec).typ;
+			  	p->info.sto = ((yyvsp[(3) - (5)].rec).sto | permission);
+				if ((yyvsp[(5) - (5)].rec).hasval)
+				{	p->info.hasval = True;
+					switch ((yyvsp[(3) - (5)].rec).typ->type)
+					{	case Tchar:
+						case Tuchar:
+						case Tshort:
+						case Tushort:
+						case Tint:
+						case Tuint:
+						case Tlong:
+						case Tulong:
+						case Tllong:
+						case Tullong:
+						case Tenum:
+						case Ttime:
+							if ((yyvsp[(5) - (5)].rec).typ->type == Tint || (yyvsp[(5) - (5)].rec).typ->type == Tchar || (yyvsp[(5) - (5)].rec).typ->type == Tenum)
+								sp->val = p->info.val.i = (yyvsp[(5) - (5)].rec).val.i;
+							else
+							{	semerror("type error in initialization constant");
+								p->info.hasval = False;
+							}
+							break;
+						case Tfloat:
+						case Tdouble:
+						case Tldouble:
+							if ((yyvsp[(5) - (5)].rec).typ->type == Tfloat || (yyvsp[(5) - (5)].rec).typ->type == Tdouble || (yyvsp[(5) - (5)].rec).typ->type == Tldouble)
+								p->info.val.r = (yyvsp[(5) - (5)].rec).val.r;
+							else if ((yyvsp[(5) - (5)].rec).typ->type == Tint)
+								p->info.val.r = (double)(yyvsp[(5) - (5)].rec).val.i;
+							else
+							{	semerror("type error in initialization constant");
+								p->info.hasval = False;
+							}
+							break;
+						default:
+							if ((yyvsp[(3) - (5)].rec).typ->type == Tpointer
+							 && ((Tnode*)(yyvsp[(3) - (5)].rec).typ->ref)->type == Tchar
+							 && (yyvsp[(5) - (5)].rec).typ->type == Tpointer
+							 && ((Tnode*)(yyvsp[(5) - (5)].rec).typ->ref)->type == Tchar)
+								p->info.val.s = (yyvsp[(5) - (5)].rec).val.s;
+							else if ((yyvsp[(3) - (5)].rec).typ->type == Tpointer
+							      && ((Tnode*)(yyvsp[(3) - (5)].rec).typ->ref)->id == lookup("std::string"))
+							      	p->info.val.s = (yyvsp[(5) - (5)].rec).val.s;
+							else if ((yyvsp[(3) - (5)].rec).typ->id == lookup("std::string"))
+							      	p->info.val.s = (yyvsp[(5) - (5)].rec).val.s;
+							else if ((yyvsp[(3) - (5)].rec).typ->type == Tpointer
+							      && (yyvsp[(5) - (5)].rec).typ->type == Tint
+							      && (yyvsp[(5) - (5)].rec).val.i == 0)
+								p->info.val.i = 0;
+							else
+							{	semerror("type error in initialization constant");
+								p->info.hasval = False;
+							}
+							break;
+					}
+				}
+				else
+					p->info.val.i = sp->val;
+			        if ((yyvsp[(4) - (5)].rec).minOccurs < 0)
+			        {	if (((yyvsp[(3) - (5)].rec).sto & Sattribute) || (yyvsp[(3) - (5)].rec).typ->type == Tpointer || (yyvsp[(3) - (5)].rec).typ->type == Ttemplate || !strncmp((yyvsp[(2) - (5)].sym)->name, "__size", 6))
+			        		p->info.minOccurs = 0;
+			        	else
+			        		p->info.minOccurs = 1;
+				}
+				else
+					p->info.minOccurs = (yyvsp[(4) - (5)].rec).minOccurs;
+				p->info.maxOccurs = (yyvsp[(4) - (5)].rec).maxOccurs;
+				if (sp->mask)
+					sp->val <<= 1;
+				else
+					sp->val++;
+			  	p->info.offset = sp->offset;
+				if ((yyvsp[(3) - (5)].rec).sto & Sextern)
+					p->level = GLOBAL;
+				else if ((yyvsp[(3) - (5)].rec).sto & Stypedef)
+					;
+			  	else if (sp->grow)
+					sp->offset += p->info.typ->width;
+				else if (p->info.typ->width > sp->offset)
+					sp->offset = p->info.typ->width;
+			  }
+			  sp->entry = p;
+			}
+    break;
+
+  case 33:
+#line 431 "soapcpp2_yacc.y"
+    { if ((yyvsp[(1) - (2)].rec).sto & Stypedef)
+			  {	sprintf(errbuf, "invalid typedef qualifier for '%s'", (yyvsp[(2) - (2)].sym)->name);
+				semwarn(errbuf);
+			  }
+			  p = enter(sp->table, (yyvsp[(2) - (2)].sym));
+			  p->info.typ = (yyvsp[(1) - (2)].rec).typ;
+			  p->info.sto = (yyvsp[(1) - (2)].rec).sto;
+			  p->info.hasval = False;
+			  p->info.offset = sp->offset;
+			  if (sp->grow)
+				sp->offset += p->info.typ->width;
+			  else if (p->info.typ->width > sp->offset)
+				sp->offset = p->info.typ->width;
+			  sp->entry = p;
+			}
+    break;
+
+  case 34:
+#line 447 "soapcpp2_yacc.y"
+    { (yyval.sym) = (yyvsp[(1) - (1)].sym); }
+    break;
+
+  case 35:
+#line 448 "soapcpp2_yacc.y"
+    { (yyval.sym) = (yyvsp[(1) - (1)].sym); }
+    break;
+
+  case 36:
+#line 450 "soapcpp2_yacc.y"
+    { (yyval.sym) = (yyvsp[(1) - (1)].sym); }
+    break;
+
+  case 37:
+#line 451 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator!"); }
+    break;
+
+  case 38:
+#line 452 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator~"); }
+    break;
+
+  case 39:
+#line 453 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator="); }
+    break;
+
+  case 40:
+#line 454 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator+="); }
+    break;
+
+  case 41:
+#line 455 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator-="); }
+    break;
+
+  case 42:
+#line 456 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator*="); }
+    break;
+
+  case 43:
+#line 457 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator/="); }
+    break;
+
+  case 44:
+#line 458 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator%="); }
+    break;
+
+  case 45:
+#line 459 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator&="); }
+    break;
+
+  case 46:
+#line 460 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator^="); }
+    break;
+
+  case 47:
+#line 461 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator|="); }
+    break;
+
+  case 48:
+#line 462 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator<<="); }
+    break;
+
+  case 49:
+#line 463 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator>>="); }
+    break;
+
+  case 50:
+#line 464 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator||"); }
+    break;
+
+  case 51:
+#line 465 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator&&"); }
+    break;
+
+  case 52:
+#line 466 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator|"); }
+    break;
+
+  case 53:
+#line 467 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator^"); }
+    break;
+
+  case 54:
+#line 468 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator&"); }
+    break;
+
+  case 55:
+#line 469 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator=="); }
+    break;
+
+  case 56:
+#line 470 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator!="); }
+    break;
+
+  case 57:
+#line 471 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator<"); }
+    break;
+
+  case 58:
+#line 472 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator<="); }
+    break;
+
+  case 59:
+#line 473 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator>"); }
+    break;
+
+  case 60:
+#line 474 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator>="); }
+    break;
+
+  case 61:
+#line 475 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator<<"); }
+    break;
+
+  case 62:
+#line 476 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator>>"); }
+    break;
+
+  case 63:
+#line 477 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator+"); }
+    break;
+
+  case 64:
+#line 478 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator-"); }
+    break;
+
+  case 65:
+#line 479 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator*"); }
+    break;
+
+  case 66:
+#line 480 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator/"); }
+    break;
+
+  case 67:
+#line 481 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator%"); }
+    break;
+
+  case 68:
+#line 482 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator++"); }
+    break;
+
+  case 69:
+#line 483 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator--"); }
+    break;
+
+  case 70:
+#line 484 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator->"); }
+    break;
+
+  case 71:
+#line 485 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator[]"); }
+    break;
+
+  case 72:
+#line 486 "soapcpp2_yacc.y"
+    { (yyval.sym) = lookup("operator()"); }
+    break;
+
+  case 73:
+#line 487 "soapcpp2_yacc.y"
+    { s1 = c_storage((yyvsp[(2) - (2)].rec).sto);
+			  s2 = c_type((yyvsp[(2) - (2)].rec).typ);
+			  s = (char*)emalloc(strlen(s1) + strlen(s2) + 10);
+			  strcpy(s, "operator ");
+			  strcat(s, s1);
+			  strcat(s, s2);
+			  (yyval.sym) = lookup(s);
+			  if (!(yyval.sym))
+				(yyval.sym) = install(s, ID);
+			}
+    break;
+
+  case 74:
+#line 498 "soapcpp2_yacc.y"
+    { if (!(p = entry(classtable, (yyvsp[(1) - (1)].sym))))
+			  	semerror("invalid constructor");
+			  sp->entry = enter(sp->table, (yyvsp[(1) - (1)].sym));
+			  sp->entry->info.typ = mknone();
+			  sp->entry->info.sto = Snone;
+			  sp->entry->info.offset = sp->offset;
+			  sp->node.typ = mkvoid();
+			  sp->node.sto = Snone;
+			}
+    break;
+
+  case 75:
+#line 509 "soapcpp2_yacc.y"
+    { if (!(p = entry(classtable, (yyvsp[(3) - (3)].sym))))
+			  	semerror("invalid destructor");
+			  s = (char*)emalloc(strlen((yyvsp[(3) - (3)].sym)->name) + 2);
+			  strcpy(s, "~");
+			  strcat(s, (yyvsp[(3) - (3)].sym)->name);
+			  sym = lookup(s);
+			  if (!sym)
+				sym = install(s, ID);
+			  sp->entry = enter(sp->table, sym);
+			  sp->entry->info.typ = mknone();
+			  sp->entry->info.sto = (yyvsp[(1) - (3)].sto);
+			  sp->entry->info.offset = sp->offset;
+			  sp->node.typ = mkvoid();
+			  sp->node.sto = Snone;
+			}
+    break;
+
+  case 76:
+#line 526 "soapcpp2_yacc.y"
+    { if ((yyvsp[(1) - (7)].e)->level == GLOBAL)
+			  {	if (!((yyvsp[(1) - (7)].e)->info.sto & Sextern) && sp->entry && sp->entry->info.typ->type == Tpointer && ((Tnode*)sp->entry->info.typ->ref)->type == Tchar)
+			  	{	sprintf(errbuf, "last output parameter of remote method function prototype '%s' is a pointer to a char which will only return one byte: use char** instead to return a string", (yyvsp[(1) - (7)].e)->sym->name);
+					semwarn(errbuf);
+				}
+				if ((yyvsp[(1) - (7)].e)->info.sto & Sextern)
+				 	(yyvsp[(1) - (7)].e)->info.typ = mkmethod((yyvsp[(1) - (7)].e)->info.typ, sp->table);
+			  	else if (sp->entry && (sp->entry->info.typ->type == Tpointer || sp->entry->info.typ->type == Treference || sp->entry->info.typ->type == Tarray || is_transient(sp->entry->info.typ)))
+				{	if ((yyvsp[(1) - (7)].e)->info.typ->type == Tint)
+					{	sp->entry->info.sto = (Storage)((int)sp->entry->info.sto | (int)Sreturn);
+						(yyvsp[(1) - (7)].e)->info.typ = mkfun(sp->entry);
+						(yyvsp[(1) - (7)].e)->info.typ->id = (yyvsp[(1) - (7)].e)->sym;
+						if (!is_transient(sp->entry->info.typ))
+						{	if (!is_response(sp->entry->info.typ))
+							{	if (!is_XML(sp->entry->info.typ))
+									add_response((yyvsp[(1) - (7)].e), sp->entry);
+							}
+							else
+								add_result(sp->entry->info.typ);
+						}
+					}
+					else
+					{	sprintf(errbuf, "return type of remote method function prototype '%s' must be integer", (yyvsp[(1) - (7)].e)->sym->name);
+						semerror(errbuf);
+					}
+				}
+			  	else
+			  	{	sprintf(errbuf, "last output parameter of remote method function prototype '%s' is a return parameter and must be a pointer or reference", (yyvsp[(1) - (7)].e)->sym->name);
+					semerror(errbuf);
+			  	}
+				if (!((yyvsp[(1) - (7)].e)->info.sto & Sextern))
+			  	{	unlinklast(sp->table);
+			  		if ((p = entry(classtable, (yyvsp[(1) - (7)].e)->sym)))
+					{	if (p->info.typ->ref)
+						{	sprintf(errbuf, "remote method name clash: struct/class '%s' already declared at line %d", (yyvsp[(1) - (7)].e)->sym->name, p->lineno);
+							semerror(errbuf);
+						}
+						else
+						{	p->info.typ->ref = sp->table;
+							p->info.typ->width = sp->offset;
+						}
+					}
+			  		else
+			  		{	p = enter(classtable, (yyvsp[(1) - (7)].e)->sym);
+						p->info.typ = mkstruct(sp->table, sp->offset);
+						p->info.typ->id = (yyvsp[(1) - (7)].e)->sym;
+			  		}
+			  	}
+			  }
+			  else if ((yyvsp[(1) - (7)].e)->level == INTERNAL)
+			  {	(yyvsp[(1) - (7)].e)->info.typ = mkmethod((yyvsp[(1) - (7)].e)->info.typ, sp->table);
+				(yyvsp[(1) - (7)].e)->info.sto = (Storage)((int)(yyvsp[(1) - (7)].e)->info.sto | (int)(yyvsp[(6) - (7)].sto) | (int)(yyvsp[(7) - (7)].sto));
+			  	transient &= ~1;
+			  }
+			  exitscope();
+			}
+    break;
+
+  case 77:
+#line 583 "soapcpp2_yacc.y"
+    { (yyval.e) = sp->entry; }
+    break;
+
+  case 78:
+#line 585 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 79:
+#line 586 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 80:
+#line 588 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 81:
+#line 589 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 82:
+#line 592 "soapcpp2_yacc.y"
+    { if ((yyvsp[(4) - (6)].rec).sto & Stypedef)
+			  	semwarn("typedef in function argument");
+			  p = enter(sp->table, (yyvsp[(3) - (6)].sym));
+			  p->info.typ = (yyvsp[(4) - (6)].rec).typ;
+			  p->info.sto = (yyvsp[(4) - (6)].rec).sto;
+			  if ((yyvsp[(5) - (6)].rec).minOccurs < 0)
+			  {	if (((yyvsp[(4) - (6)].rec).sto & Sattribute) || (yyvsp[(4) - (6)].rec).typ->type == Tpointer)
+			        	p->info.minOccurs = 0;
+			       	else
+			        	p->info.minOccurs = 1;
+			  }
+			  else
+				p->info.minOccurs = (yyvsp[(5) - (6)].rec).minOccurs;
+			  p->info.maxOccurs = (yyvsp[(5) - (6)].rec).maxOccurs;
+			  if ((yyvsp[(6) - (6)].rec).hasval)
+			  {	p->info.hasval = True;
+				switch ((yyvsp[(4) - (6)].rec).typ->type)
+				{	case Tchar:
+					case Tuchar:
+					case Tshort:
+					case Tushort:
+					case Tint:
+					case Tuint:
+					case Tlong:
+					case Tulong:
+					case Tenum:
+					case Ttime:
+						if ((yyvsp[(6) - (6)].rec).typ->type == Tint || (yyvsp[(6) - (6)].rec).typ->type == Tchar || (yyvsp[(6) - (6)].rec).typ->type == Tenum)
+							sp->val = p->info.val.i = (yyvsp[(6) - (6)].rec).val.i;
+						else
+						{	semerror("type error in initialization constant");
+							p->info.hasval = False;
+						}
+						break;
+					case Tfloat:
+					case Tdouble:
+					case Tldouble:
+						if ((yyvsp[(6) - (6)].rec).typ->type == Tfloat || (yyvsp[(6) - (6)].rec).typ->type == Tdouble || (yyvsp[(6) - (6)].rec).typ->type == Tldouble)
+							p->info.val.r = (yyvsp[(6) - (6)].rec).val.r;
+						else if ((yyvsp[(6) - (6)].rec).typ->type == Tint)
+							p->info.val.r = (double)(yyvsp[(6) - (6)].rec).val.i;
+						else
+						{	semerror("type error in initialization constant");
+							p->info.hasval = False;
+						}
+						break;
+					default:
+						if ((yyvsp[(4) - (6)].rec).typ->type == Tpointer
+						 && ((Tnode*)(yyvsp[(4) - (6)].rec).typ->ref)->type == Tchar
+						 && (yyvsp[(6) - (6)].rec).typ->type == Tpointer
+						 && ((Tnode*)(yyvsp[(6) - (6)].rec).typ->ref)->type == Tchar)
+							p->info.val.s = (yyvsp[(6) - (6)].rec).val.s;
+						else if ((yyvsp[(4) - (6)].rec).typ->type == Tpointer
+						      && ((Tnode*)(yyvsp[(4) - (6)].rec).typ->ref)->id == lookup("std::string"))
+						      	p->info.val.s = (yyvsp[(6) - (6)].rec).val.s;
+						else if ((yyvsp[(4) - (6)].rec).typ->id == lookup("std::string"))
+						      	p->info.val.s = (yyvsp[(6) - (6)].rec).val.s;
+						else if ((yyvsp[(4) - (6)].rec).typ->type == Tpointer
+						      && (yyvsp[(6) - (6)].rec).typ->type == Tint
+						      && (yyvsp[(6) - (6)].rec).val.i == 0)
+							p->info.val.i = 0;
+						else
+						{	semerror("type error in initialization constant");
+							p->info.hasval = False;
+						}
+						break;
+				}
+			  }
+			  p->info.offset = sp->offset;
+			  if ((yyvsp[(4) - (6)].rec).sto & Sextern)
+				p->level = GLOBAL;
+			  else if (sp->grow)
+				sp->offset += p->info.typ->width;
+			  else if (p->info.typ->width > sp->offset)
+				sp->offset = p->info.typ->width;
+			  sp->entry = p;
+			}
+    break;
+
+  case 83:
+#line 670 "soapcpp2_yacc.y"
+    { if (sp->table->level != PARAM)
+			    (yyval.sym) = gensymidx("param", (int)++sp->val);
+			  else if (eflag)
+				(yyval.sym) = gensymidx("_param", (int)++sp->val);
+			  else
+				(yyval.sym) = gensym("_param");
+			}
+    break;
+
+  case 84:
+#line 677 "soapcpp2_yacc.y"
+    { if (vflag != 1 && *(yyvsp[(1) - (1)].sym)->name == '_' && sp->table->level == GLOBAL)
+			  { sprintf(errbuf, "SOAP 1.2 does not support anonymous parameters '%s'", (yyvsp[(1) - (1)].sym)->name);
+			    semwarn(errbuf);
+			  }
+			  (yyval.sym) = (yyvsp[(1) - (1)].sym);
+			}
+    break;
+
+  case 85:
+#line 693 "soapcpp2_yacc.y"
+    { (yyval.rec) = (yyvsp[(3) - (3)].rec); }
+    break;
+
+  case 86:
+#line 695 "soapcpp2_yacc.y"
+    { (yyval.rec) = (yyvsp[(4) - (4)].rec); }
+    break;
+
+  case 87:
+#line 697 "soapcpp2_yacc.y"
+    { (yyval.rec).typ = mkint();
+			  (yyval.rec).sto = Snone;
+			  sp->node = (yyval.rec);
+			}
+    break;
+
+  case 88:
+#line 701 "soapcpp2_yacc.y"
+    { (yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ;
+			  (yyval.rec).sto = (Storage)((int)(yyvsp[(1) - (2)].sto) | (int)(yyvsp[(2) - (2)].rec).sto);
+			  if (((yyval.rec).sto & Sattribute) && !is_primitive_or_string((yyvsp[(2) - (2)].rec).typ) && !is_stdstr((yyvsp[(2) - (2)].rec).typ) && !is_binary((yyvsp[(2) - (2)].rec).typ) && !is_external((yyvsp[(2) - (2)].rec).typ))
+			  {	semwarn("invalid attribute type");
+			  	(yyval.rec).sto &= ~Sattribute;
+			  }
+			  sp->node = (yyval.rec);
+			  if ((yyvsp[(1) - (2)].sto) & Sextern)
+				transient = 0;
+			}
+    break;
+
+  case 89:
+#line 711 "soapcpp2_yacc.y"
+    { if ((yyvsp[(1) - (2)].typ)->type == Tint)
+				switch ((yyvsp[(2) - (2)].rec).typ->type)
+				{ case Tchar:	(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ; break;
+				  case Tshort:	(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ; break;
+				  case Tint:	(yyval.rec).typ = (yyvsp[(1) - (2)].typ); break;
+				  case Tlong:	(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ; break;
+				  case Tllong:	(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ; break;
+				  default:	semwarn("illegal use of 'signed'");
+						(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ;
+				}
+			  else if ((yyvsp[(1) - (2)].typ)->type == Tuint)
+				switch ((yyvsp[(2) - (2)].rec).typ->type)
+				{ case Tchar:	(yyval.rec).typ = mkuchar(); break;
+				  case Tshort:	(yyval.rec).typ = mkushort(); break;
+				  case Tint:	(yyval.rec).typ = (yyvsp[(1) - (2)].typ); break;
+				  case Tlong:	(yyval.rec).typ = mkulong(); break;
+				  case Tllong:	(yyval.rec).typ = mkullong(); break;
+				  default:	semwarn("illegal use of 'unsigned'");
+						(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ;
+				}
+			  else if ((yyvsp[(1) - (2)].typ)->type == Tlong)
+				switch ((yyvsp[(2) - (2)].rec).typ->type)
+				{ case Tint:	(yyval.rec).typ = (yyvsp[(1) - (2)].typ); break;
+				  case Tlong:	(yyval.rec).typ = mkllong(); break;
+				  case Tuint:	(yyval.rec).typ = mkulong(); break;
+				  case Tulong:	(yyval.rec).typ = mkullong(); break;
+				  case Tdouble:	(yyval.rec).typ = mkldouble(); break;
+				  default:	semwarn("illegal use of 'long'");
+						(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ;
+				}
+			  else if ((yyvsp[(1) - (2)].typ)->type == Tulong)
+				switch ((yyvsp[(2) - (2)].rec).typ->type)
+				{ case Tint:	(yyval.rec).typ = (yyvsp[(1) - (2)].typ); break;
+				  case Tlong:	(yyval.rec).typ = mkullong(); break;
+				  case Tuint:	(yyval.rec).typ = (yyvsp[(1) - (2)].typ); break;
+				  case Tulong:	(yyval.rec).typ = mkullong(); break;
+				  default:	semwarn("illegal use of 'long'");
+						(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ;
+				}
+			  else if ((yyvsp[(2) - (2)].rec).typ->type == Tint)
+				(yyval.rec).typ = (yyvsp[(1) - (2)].typ);
+			  else
+			  	semwarn("invalid type (missing ';'?)");
+			  (yyval.rec).sto = (yyvsp[(2) - (2)].rec).sto;
+			  sp->node = (yyval.rec);
+			}
+    break;
+
+  case 90:
+#line 758 "soapcpp2_yacc.y"
+    { (yyval.rec).typ = mkint();
+			  (yyval.rec).sto = (yyvsp[(1) - (1)].sto);
+			  sp->node = (yyval.rec);
+			  if ((yyvsp[(1) - (1)].sto) & Sextern)
+				transient = 0;
+			}
+    break;
+
+  case 91:
+#line 764 "soapcpp2_yacc.y"
+    { (yyval.rec).typ = (yyvsp[(1) - (1)].typ);
+			  (yyval.rec).sto = Snone;
+			  sp->node = (yyval.rec);
+			}
+    break;
+
+  case 92:
+#line 768 "soapcpp2_yacc.y"
+    { (yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ;
+			  (yyval.rec).sto = (Storage)((int)(yyvsp[(1) - (2)].sto) | (int)(yyvsp[(2) - (2)].rec).sto);
+			  if (((yyval.rec).sto & Sattribute) && !is_primitive_or_string((yyvsp[(2) - (2)].rec).typ) && !is_stdstr((yyvsp[(2) - (2)].rec).typ) && !is_binary((yyvsp[(2) - (2)].rec).typ) && !is_external((yyvsp[(2) - (2)].rec).typ))
+			  {	semwarn("invalid attribute type");
+			  	(yyval.rec).sto &= ~Sattribute;
+			  }
+			  sp->node = (yyval.rec);
+			  if ((yyvsp[(1) - (2)].sto) & Sextern)
+				transient = 0;
+			}
+    break;
+
+  case 93:
+#line 778 "soapcpp2_yacc.y"
+    { if ((yyvsp[(1) - (2)].typ)->type == Tint)
+				switch ((yyvsp[(2) - (2)].rec).typ->type)
+				{ case Tchar:	(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ; break;
+				  case Tshort:	(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ; break;
+				  case Tint:	(yyval.rec).typ = (yyvsp[(1) - (2)].typ); break;
+				  case Tlong:	(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ; break;
+				  case Tllong:	(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ; break;
+				  default:	semwarn("illegal use of 'signed'");
+						(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ;
+				}
+			  else if ((yyvsp[(1) - (2)].typ)->type == Tuint)
+				switch ((yyvsp[(2) - (2)].rec).typ->type)
+				{ case Tchar:	(yyval.rec).typ = mkuchar(); break;
+				  case Tshort:	(yyval.rec).typ = mkushort(); break;
+				  case Tint:	(yyval.rec).typ = (yyvsp[(1) - (2)].typ); break;
+				  case Tlong:	(yyval.rec).typ = mkulong(); break;
+				  case Tllong:	(yyval.rec).typ = mkullong(); break;
+				  default:	semwarn("illegal use of 'unsigned'");
+						(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ;
+				}
+			  else if ((yyvsp[(1) - (2)].typ)->type == Tlong)
+				switch ((yyvsp[(2) - (2)].rec).typ->type)
+				{ case Tint:	(yyval.rec).typ = (yyvsp[(1) - (2)].typ); break;
+				  case Tlong:	(yyval.rec).typ = mkllong(); break;
+				  case Tuint:	(yyval.rec).typ = mkulong(); break;
+				  case Tulong:	(yyval.rec).typ = mkullong(); break;
+				  case Tdouble:	(yyval.rec).typ = mkldouble(); break;
+				  default:	semwarn("illegal use of 'long'");
+						(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ;
+				}
+			  else if ((yyvsp[(1) - (2)].typ)->type == Tulong)
+				switch ((yyvsp[(2) - (2)].rec).typ->type)
+				{ case Tint:	(yyval.rec).typ = (yyvsp[(1) - (2)].typ); break;
+				  case Tlong:	(yyval.rec).typ = mkullong(); break;
+				  case Tuint:	(yyval.rec).typ = (yyvsp[(1) - (2)].typ); break;
+				  case Tulong:	(yyval.rec).typ = mkullong(); break;
+				  default:	semwarn("illegal use of 'long'");
+						(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ;
+				}
+			  else if ((yyvsp[(2) - (2)].rec).typ->type == Tint)
+				(yyval.rec).typ = (yyvsp[(1) - (2)].typ);
+			  else
+			  	semwarn("invalid type");
+			  (yyval.rec).sto = (yyvsp[(2) - (2)].rec).sto;
+			  sp->node = (yyval.rec);
+			}
+    break;
+
+  case 94:
+#line 825 "soapcpp2_yacc.y"
+    { (yyval.typ) = mkvoid(); }
+    break;
+
+  case 95:
+#line 826 "soapcpp2_yacc.y"
+    { (yyval.typ) = mkbool(); }
+    break;
+
+  case 96:
+#line 827 "soapcpp2_yacc.y"
+    { (yyval.typ) = mkchar(); }
+    break;
+
+  case 97:
+#line 828 "soapcpp2_yacc.y"
+    { (yyval.typ) = mkwchart(); }
+    break;
+
+  case 98:
+#line 829 "soapcpp2_yacc.y"
+    { (yyval.typ) = mkshort(); }
+    break;
+
+  case 99:
+#line 830 "soapcpp2_yacc.y"
+    { (yyval.typ) = mkint(); }
+    break;
+
+  case 100:
+#line 831 "soapcpp2_yacc.y"
+    { (yyval.typ) = mklong(); }
+    break;
+
+  case 101:
+#line 832 "soapcpp2_yacc.y"
+    { (yyval.typ) = mkllong(); }
+    break;
+
+  case 102:
+#line 833 "soapcpp2_yacc.y"
+    { (yyval.typ) = mkullong(); }
+    break;
+
+  case 103:
+#line 834 "soapcpp2_yacc.y"
+    { (yyval.typ) = mkulong(); }
+    break;
+
+  case 104:
+#line 835 "soapcpp2_yacc.y"
+    { (yyval.typ) = mkfloat(); }
+    break;
+
+  case 105:
+#line 836 "soapcpp2_yacc.y"
+    { (yyval.typ) = mkdouble(); }
+    break;
+
+  case 106:
+#line 837 "soapcpp2_yacc.y"
+    { (yyval.typ) = mkint(); }
+    break;
+
+  case 107:
+#line 838 "soapcpp2_yacc.y"
+    { (yyval.typ) = mkuint(); }
+    break;
+
+  case 108:
+#line 839 "soapcpp2_yacc.y"
+    { (yyval.typ) = mktimet(); }
+    break;
+
+  case 109:
+#line 841 "soapcpp2_yacc.y"
+    { if (!(p = entry(templatetable, (yyvsp[(7) - (7)].sym))))
+			  {	p = enter(templatetable, (yyvsp[(7) - (7)].sym));
+			  	p->info.typ = mktemplate(NULL, (yyvsp[(7) - (7)].sym));
+			  	(yyvsp[(7) - (7)].sym)->token = TYPE;
+			  }
+			  (yyval.typ) = p->info.typ;
+			}
+    break;
+
+  case 110:
+#line 849 "soapcpp2_yacc.y"
+    { sym = gensym("_Struct");
+			  sprintf(errbuf, "anonymous class will be named '%s'", sym->name);
+			  semwarn(errbuf);
+			  if ((p = entry(classtable, sym)))
+			  {	if (p->info.typ->ref || p->info.typ->type != Tclass)
+				{	sprintf(errbuf, "class '%s' already declared at line %d", sym->name, p->lineno);
+					semerror(errbuf);
+				}
+			  }
+			  else
+			  {	p = enter(classtable, sym);
+				p->info.typ = mkclass((Table*)0, 0);
+			  }
+			  sym->token = TYPE;
+			  sp->table->sym = sym;
+			  p->info.typ->ref = sp->table;
+			  p->info.typ->width = sp->offset;
+			  p->info.typ->id = sym;
+			  (yyval.typ) = p->info.typ;
+			  exitscope();
+			}
+    break;
+
+  case 111:
+#line 871 "soapcpp2_yacc.y"
+    { p = reenter(classtable, (yyvsp[(1) - (5)].e)->sym);
+			  sp->table->sym = p->sym;
+			  p->info.typ->ref = sp->table;
+			  p->info.typ->width = sp->offset;
+			  p->info.typ->id = p->sym;
+			  if (p->info.typ->base)
+			  	sp->table->prev = (Table*)entry(classtable, p->info.typ->base)->info.typ->ref;
+			  (yyval.typ) = p->info.typ;
+			  exitscope();
+			}
+    break;
+
+  case 112:
+#line 882 "soapcpp2_yacc.y"
+    { p = reenter(classtable, (yyvsp[(1) - (7)].e)->sym);
+			  sp->table->sym = p->sym;
+			  if (!(yyvsp[(3) - (7)].e))
+				semerror("invalid base class");
+			  else
+			  {	sp->table->prev = (Table*)(yyvsp[(3) - (7)].e)->info.typ->ref;
+				if (!sp->table->prev && !(yyvsp[(3) - (7)].e)->info.typ->transient)
+				{	sprintf(errbuf, "class '%s' has incomplete type", (yyvsp[(3) - (7)].e)->sym->name);
+					semerror(errbuf);
+				}
+			  	p->info.typ->base = (yyvsp[(3) - (7)].e)->info.typ->id;
+			  }
+			  p->info.typ->ref = sp->table;
+			  p->info.typ->width = sp->offset;
+			  p->info.typ->id = p->sym;
+			  (yyval.typ) = p->info.typ;
+			  exitscope();
+			}
+    break;
+
+  case 113:
+#line 900 "soapcpp2_yacc.y"
+    { (yyvsp[(1) - (1)].e)->info.typ->id = (yyvsp[(1) - (1)].e)->sym;
+			  (yyval.typ) = (yyvsp[(1) - (1)].e)->info.typ;
+			}
+    break;
+
+  case 114:
+#line 904 "soapcpp2_yacc.y"
+    { if (!(yyvsp[(3) - (3)].e))
+				semerror("invalid base class");
+			  else
+			  {	if (!(yyvsp[(3) - (3)].e)->info.typ->ref && !(yyvsp[(3) - (3)].e)->info.typ->transient)
+				{	sprintf(errbuf, "class '%s' has incomplete type", (yyvsp[(3) - (3)].e)->sym->name);
+					semerror(errbuf);
+				}
+			  	(yyvsp[(1) - (3)].e)->info.typ->base = (yyvsp[(3) - (3)].e)->info.typ->id;
+			  }
+			  (yyvsp[(1) - (3)].e)->info.typ->id = (yyvsp[(1) - (3)].e)->sym;
+			  (yyval.typ) = (yyvsp[(1) - (3)].e)->info.typ;
+			}
+    break;
+
+  case 115:
+#line 917 "soapcpp2_yacc.y"
+    { sym = gensym("_Struct");
+			  sprintf(errbuf, "anonymous struct will be named '%s'", sym->name);
+			  semwarn(errbuf);
+			  if ((p = entry(classtable, sym)))
+			  {	if (p->info.typ->ref || p->info.typ->type != Tstruct)
+				{	sprintf(errbuf, "struct '%s' already declared at line %d", sym->name, p->lineno);
+					semerror(errbuf);
+				}
+				else
+				{	p->info.typ->ref = sp->table;
+					p->info.typ->width = sp->offset;
+				}
+			  }
+			  else
+			  {	p = enter(classtable, sym);
+				p->info.typ = mkstruct(sp->table, sp->offset);
+			  }
+			  p->info.typ->id = sym;
+			  (yyval.typ) = p->info.typ;
+			  exitscope();
+			}
+    break;
+
+  case 116:
+#line 939 "soapcpp2_yacc.y"
+    { if ((p = entry(classtable, (yyvsp[(1) - (5)].e)->sym)) && p->info.typ->ref)
+			  {	if (is_mutable(p->info.typ))
+			  	{	if (merge((Table*)p->info.typ->ref, sp->table))
+					{	sprintf(errbuf, "member name clash in struct '%s' declared at line %d", (yyvsp[(1) - (5)].e)->sym->name, p->lineno);
+						semerror(errbuf);
+					}
+			  		p->info.typ->width += sp->offset;
+				}
+			  }
+			  else
+			  {	p = reenter(classtable, (yyvsp[(1) - (5)].e)->sym);
+			  	p->info.typ->ref = sp->table;
+			  	p->info.typ->width = sp->offset;
+			  	p->info.typ->id = p->sym;
+			  }
+			  (yyval.typ) = p->info.typ;
+			  exitscope();
+			}
+    break;
+
+  case 117:
+#line 957 "soapcpp2_yacc.y"
+    { if ((p = entry(classtable, (yyvsp[(2) - (2)].sym))))
+			  {	if (p->info.typ->type == Tstruct)
+			  		(yyval.typ) = p->info.typ;
+			  	else
+				{	sprintf(errbuf, "'struct %s' redeclaration (line %d)", (yyvsp[(2) - (2)].sym)->name, p->lineno);
+			  		semerror(errbuf);
+			  		(yyval.typ) = mkint();
+				}
+			  }
+			  else
+			  {	p = enter(classtable, (yyvsp[(2) - (2)].sym));
+			  	(yyval.typ) = p->info.typ = mkstruct((Table*)0, 0);
+				p->info.typ->id = (yyvsp[(2) - (2)].sym);
+			  }
+			}
+    break;
+
+  case 118:
+#line 972 "soapcpp2_yacc.y"
+    { if ((p = entry(classtable, (yyvsp[(2) - (2)].sym))))
+			  {	if (p->info.typ->type == Tstruct)
+					(yyval.typ) = p->info.typ;
+			  	else
+				{	sprintf(errbuf, "'struct %s' redeclaration (line %d)", (yyvsp[(2) - (2)].sym)->name, p->lineno);
+			  		semerror(errbuf);
+			  		(yyval.typ) = mkint();
+				}
+			  }
+			  else
+			  {	p = enter(classtable, (yyvsp[(2) - (2)].sym));
+			  	(yyval.typ) = p->info.typ = mkstruct((Table*)0, 0);
+				p->info.typ->id = (yyvsp[(2) - (2)].sym);
+			  }
+			}
+    break;
+
+  case 119:
+#line 988 "soapcpp2_yacc.y"
+    { sym = gensym("_Union");
+			  sprintf(errbuf, "anonymous union will be named '%s'", sym->name);
+			  semwarn(errbuf);
+			  (yyval.typ) = mkunion(sp->table, sp->offset);
+			  if ((p = entry(classtable, sym)))
+			  {	if ((Table*) p->info.typ->ref)
+				{	sprintf(errbuf, "union or struct '%s' already declared at line %d", sym->name, p->lineno);
+					semerror(errbuf);
+				}
+				else
+				{	p->info.typ->ref = sp->table;
+					p->info.typ->width = sp->offset;
+				}
+			  }
+			  else
+			  {	p = enter(classtable, sym);
+				p->info.typ = mkunion(sp->table, sp->offset);
+			  }
+			  p->info.typ->id = sym;
+			  (yyval.typ) = p->info.typ;
+			  exitscope();
+			}
+    break;
+
+  case 120:
+#line 1011 "soapcpp2_yacc.y"
+    { if ((p = entry(classtable, (yyvsp[(2) - (6)].sym))))
+			  {	if (p->info.typ->ref || p->info.typ->type != Tunion)
+			  	{	sprintf(errbuf, "union '%s' already declared at line %d", (yyvsp[(2) - (6)].sym)->name, p->lineno);
+					semerror(errbuf);
+				}
+				else
+				{	p = reenter(classtable, (yyvsp[(2) - (6)].sym));
+					p->info.typ->ref = sp->table;
+					p->info.typ->width = sp->offset;
+				}
+			  }
+			  else
+			  {	p = enter(classtable, (yyvsp[(2) - (6)].sym));
+				p->info.typ = mkunion(sp->table, sp->offset);
+			  }
+			  p->info.typ->id = (yyvsp[(2) - (6)].sym);
+			  (yyval.typ) = p->info.typ;
+			  exitscope();
+			}
+    break;
+
+  case 121:
+#line 1030 "soapcpp2_yacc.y"
+    { if ((p = entry(classtable, (yyvsp[(2) - (2)].sym))))
+			  {	if (p->info.typ->type == Tunion)
+					(yyval.typ) = p->info.typ;
+			  	else
+				{	sprintf(errbuf, "'union %s' redeclaration (line %d)", (yyvsp[(2) - (2)].sym)->name, p->lineno);
+			  		semerror(errbuf);
+			  		(yyval.typ) = mkint();
+				}
+			  }
+			  else
+			  {	p = enter(classtable, (yyvsp[(2) - (2)].sym));
+			  	(yyval.typ) = p->info.typ = mkunion((Table*) 0, 0);
+				p->info.typ->id = (yyvsp[(2) - (2)].sym);
+			  }
+			}
+    break;
+
+  case 122:
+#line 1045 "soapcpp2_yacc.y"
+    { if ((p = entry(classtable, (yyvsp[(2) - (2)].sym))))
+			  {	if (p->info.typ->type == Tunion)
+					(yyval.typ) = p->info.typ;
+			  	else
+				{	sprintf(errbuf, "'union %s' redeclaration (line %d)", (yyvsp[(2) - (2)].sym)->name, p->lineno);
+			  		semerror(errbuf);
+			  		(yyval.typ) = mkint();
+				}
+			  }
+			  else
+			  {	p = enter(classtable, (yyvsp[(2) - (2)].sym));
+			  	(yyval.typ) = p->info.typ = mkunion((Table*) 0, 0);
+				p->info.typ->id = (yyvsp[(2) - (2)].sym);
+			  }
+			}
+    break;
+
+  case 123:
+#line 1061 "soapcpp2_yacc.y"
+    { sym = gensym("_Enum");
+			  sprintf(errbuf, "anonymous enum will be named '%s'", sym->name);
+			  semwarn(errbuf);
+			  if ((p = entry(enumtable, sym)))
+			  {	if ((Table*) p->info.typ->ref)
+				{	sprintf(errbuf, "enum '%s' already declared at line %d", sym->name, p->lineno);
+					semerror(errbuf);
+				}
+				else
+				{	p->info.typ->ref = sp->table;
+					p->info.typ->width = 4; /* 4 = enum */
+				}
+			  }
+			  else
+			  {	p = enter(enumtable, sym);
+				p->info.typ = mkenum(sp->table);
+			  }
+			  p->info.typ->id = sym;
+			  (yyval.typ) = p->info.typ;
+			  exitscope();
+			}
+    break;
+
+  case 124:
+#line 1083 "soapcpp2_yacc.y"
+    { if ((p = entry(enumtable, (yyvsp[(1) - (6)].e)->sym)))
+			  {	if ((Table*) p->info.typ->ref)
+				{	sprintf(errbuf, "enum '%s' already declared at line %d", (yyvsp[(1) - (6)].e)->sym->name, p->lineno);
+					semerror(errbuf);
+				}
+				else
+				{	p->info.typ->ref = sp->table;
+					p->info.typ->width = 4; /* 4 = enum */
+				}
+			  }
+			  else
+			  {	p = enter(enumtable, (yyvsp[(1) - (6)].e)->sym);
+				p->info.typ = mkenum(sp->table);
+			  }
+			  p->info.typ->id = (yyvsp[(1) - (6)].e)->sym;
+			  (yyval.typ) = p->info.typ;
+			  exitscope();
+			}
+    break;
+
+  case 125:
+#line 1102 "soapcpp2_yacc.y"
+    { if ((p = entry(enumtable, (yyvsp[(3) - (8)].sym))))
+			  {	if (p->info.typ->ref)
+				{	sprintf(errbuf, "enum '%s' already declared at line %d", (yyvsp[(3) - (8)].sym)->name, p->lineno);
+					semerror(errbuf);
+				}
+				else
+				{	p->info.typ->ref = sp->table;
+					p->info.typ->width = 8; /* 8 = mask */
+				}
+			  }
+			  else
+			  {	p = enter(enumtable, (yyvsp[(3) - (8)].sym));
+				p->info.typ = mkmask(sp->table);
+			  }
+			  p->info.typ->id = (yyvsp[(3) - (8)].sym);
+			  (yyval.typ) = p->info.typ;
+			  exitscope();
+			}
+    break;
+
+  case 126:
+#line 1120 "soapcpp2_yacc.y"
+    { if ((p = entry(enumtable, (yyvsp[(2) - (2)].sym))))
+			  	(yyval.typ) = p->info.typ;
+			  else
+			  {	p = enter(enumtable, (yyvsp[(2) - (2)].sym));
+			  	(yyval.typ) = p->info.typ = mkenum((Table*)0);
+				p->info.typ->id = (yyvsp[(2) - (2)].sym);
+			  }
+			}
+    break;
+
+  case 127:
+#line 1128 "soapcpp2_yacc.y"
+    { if ((p = entry(enumtable, (yyvsp[(2) - (2)].sym))))
+				(yyval.typ) = p->info.typ;
+			  else
+			  {	p = enter(enumtable, (yyvsp[(2) - (2)].sym));
+			  	(yyval.typ) = p->info.typ = mkenum((Table*)0);
+				p->info.typ->id = (yyvsp[(2) - (2)].sym);
+			  }
+			}
+    break;
+
+  case 128:
+#line 1136 "soapcpp2_yacc.y"
+    { if ((p = entry(typetable, (yyvsp[(1) - (1)].sym))))
+				(yyval.typ) = p->info.typ;
+			  else if ((p = entry(classtable, (yyvsp[(1) - (1)].sym))))
+			  	(yyval.typ) = p->info.typ;
+			  else if ((p = entry(enumtable, (yyvsp[(1) - (1)].sym))))
+			  	(yyval.typ) = p->info.typ;
+			  else if ((yyvsp[(1) - (1)].sym) == lookup("std::string") || (yyvsp[(1) - (1)].sym) == lookup("std::wstring"))
+			  {	p = enter(classtable, (yyvsp[(1) - (1)].sym));
+				(yyval.typ) = p->info.typ = mkclass((Table*)0, 0);
+			  	p->info.typ->id = (yyvsp[(1) - (1)].sym);
+			  	p->info.typ->transient = -2;
+			  }
+			  else
+			  {	sprintf(errbuf, "unknown type '%s'", (yyvsp[(1) - (1)].sym)->name);
+				semerror(errbuf);
+				(yyval.typ) = mkint();
+			  }
+			}
+    break;
+
+  case 129:
+#line 1155 "soapcpp2_yacc.y"
+    { if ((p = entry(templatetable, (yyvsp[(1) - (4)].sym))))
+				(yyval.typ) = mktemplate((yyvsp[(3) - (4)].rec).typ, (yyvsp[(1) - (4)].sym));
+			  else
+			  {	sprintf(errbuf, "invalid template '%s'", (yyvsp[(1) - (4)].sym)->name);
+				semerror(errbuf);
+				(yyval.typ) = mkint();
+			  }
+			}
+    break;
+
+  case 130:
+#line 1164 "soapcpp2_yacc.y"
+    { if ((p = entry(classtable, (yyvsp[(2) - (2)].sym))))
+			  {	if (p->info.typ->ref)
+			   	{	if (!is_mutable(p->info.typ))
+					{	sprintf(errbuf, "struct '%s' already declared at line %d", (yyvsp[(2) - (2)].sym)->name, p->lineno);
+						semerror(errbuf);
+					}
+				}
+				else
+					p = reenter(classtable, (yyvsp[(2) - (2)].sym));
+			  }
+			  else
+			  {	p = enter(classtable, (yyvsp[(2) - (2)].sym));
+				p->info.typ = mkstruct((Table*)0, 0);
+			  }
+			  (yyval.e) = p;
+			}
+    break;
+
+  case 131:
+#line 1181 "soapcpp2_yacc.y"
+    { if ((p = entry(classtable, (yyvsp[(2) - (2)].sym))))
+			  {	if (p->info.typ->ref)
+			   	{	if (!is_mutable(p->info.typ))
+					{	sprintf(errbuf, "class '%s' already declared at line %d", (yyvsp[(2) - (2)].sym)->name, p->lineno);
+						semerror(errbuf);
+					}
+				}
+				else
+					p = reenter(classtable, (yyvsp[(2) - (2)].sym));
+			  }
+			  else
+			  {	p = enter(classtable, (yyvsp[(2) - (2)].sym));
+				p->info.typ = mkclass((Table*)0, 0);
+				p->info.typ->id = p->sym;
+			  }
+			  (yyvsp[(2) - (2)].sym)->token = TYPE;
+			  (yyval.e) = p;
+			}
+    break;
+
+  case 132:
+#line 1200 "soapcpp2_yacc.y"
+    { if ((p = entry(enumtable, (yyvsp[(2) - (2)].sym))))
+			  {	if (p->info.typ->ref)
+				{	sprintf(errbuf, "enum '%s' already declared at line %d", (yyvsp[(2) - (2)].sym)->name, p->lineno);
+					semerror(errbuf);
+				}
+				/*
+				else
+					p = reenter(classtable, $2);
+			  	*/
+			  }
+			  else
+			  {	p = enter(enumtable, (yyvsp[(2) - (2)].sym));
+				p->info.typ = mkenum(0);
+			  }
+			  (yyval.e) = p;
+			}
+    break;
+
+  case 133:
+#line 1217 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 134:
+#line 1218 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 135:
+#line 1220 "soapcpp2_yacc.y"
+    { (yyval.e) = (yyvsp[(2) - (2)].e); }
+    break;
+
+  case 136:
+#line 1221 "soapcpp2_yacc.y"
+    { (yyval.e) = (yyvsp[(2) - (2)].e); }
+    break;
+
+  case 137:
+#line 1222 "soapcpp2_yacc.y"
+    { (yyval.e) = (yyvsp[(2) - (2)].e); }
+    break;
+
+  case 138:
+#line 1223 "soapcpp2_yacc.y"
+    { (yyval.e) = entry(classtable, (yyvsp[(1) - (1)].sym));
+			  if (!(yyval.e))
+			  {	p = entry(typetable, (yyvsp[(1) - (1)].sym));
+			  	if (p && (p->info.typ->type == Tclass || p->info.typ->type == Tstruct))
+					(yyval.e) = p;
+			  }
+			}
+    break;
+
+  case 139:
+#line 1230 "soapcpp2_yacc.y"
+    { (yyval.e) = entry(classtable, (yyvsp[(2) - (2)].sym)); }
+    break;
+
+  case 140:
+#line 1232 "soapcpp2_yacc.y"
+    { if (transient == -2)
+			  	transient = 0;
+			  permission = 0;
+			  enterscope(mktable(NULL), 0);
+			  sp->entry = NULL;
+			}
+    break;
+
+  case 141:
+#line 1239 "soapcpp2_yacc.y"
+    { if (transient == -2)
+			  	transient = 0;
+			  permission = 0;
+			  enterscope(mktable(NULL), 0);
+			  sp->entry = NULL;
+			  sp->grow = False;
+			}
+    break;
+
+  case 142:
+#line 1247 "soapcpp2_yacc.y"
+    { enterscope(mktable(NULL), 0);
+			  sp->entry = NULL;
+			  sp->mask = True;
+			  sp->val = 1;
+			}
+    break;
+
+  case 143:
+#line 1253 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 144:
+#line 1254 "soapcpp2_yacc.y"
+    { }
+    break;
+
+  case 145:
+#line 1256 "soapcpp2_yacc.y"
+    { if (sp->table->level == INTERNAL)
+			  	transient |= 1;
+			  permission = 0;
+			  enterscope(mktable(NULL), 0);
+			  sp->entry = NULL;
+			  sp->table->level = PARAM;
+			}
+    break;
+
+  case 146:
+#line 1264 "soapcpp2_yacc.y"
+    { (yyval.sto) = Sauto; }
+    break;
+
+  case 147:
+#line 1265 "soapcpp2_yacc.y"
+    { (yyval.sto) = Sregister; }
+    break;
+
+  case 148:
+#line 1266 "soapcpp2_yacc.y"
+    { (yyval.sto) = Sstatic; }
+    break;
+
+  case 149:
+#line 1267 "soapcpp2_yacc.y"
+    { (yyval.sto) = Sexplicit; }
+    break;
+
+  case 150:
+#line 1268 "soapcpp2_yacc.y"
+    { (yyval.sto) = Sextern; transient = 1; }
+    break;
+
+  case 151:
+#line 1269 "soapcpp2_yacc.y"
+    { (yyval.sto) = Stypedef; }
+    break;
+
+  case 152:
+#line 1270 "soapcpp2_yacc.y"
+    { (yyval.sto) = Svirtual; }
+    break;
+
+  case 153:
+#line 1271 "soapcpp2_yacc.y"
+    { (yyval.sto) = Sconst; }
+    break;
+
+  case 154:
+#line 1272 "soapcpp2_yacc.y"
+    { (yyval.sto) = Sfriend; }
+    break;
+
+  case 155:
+#line 1273 "soapcpp2_yacc.y"
+    { (yyval.sto) = Sinline; }
+    break;
+
+  case 156:
+#line 1274 "soapcpp2_yacc.y"
+    { (yyval.sto) = SmustUnderstand; }
+    break;
+
+  case 157:
+#line 1275 "soapcpp2_yacc.y"
+    { (yyval.sto) = Sreturn; }
+    break;
+
+  case 158:
+#line 1276 "soapcpp2_yacc.y"
+    { (yyval.sto) = Sattribute;
+			  if (eflag)
+			   	semwarn("SOAP RPC encoding does not support XML attributes");
+			}
+    break;
+
+  case 159:
+#line 1280 "soapcpp2_yacc.y"
+    { (yyval.sto) = Sextern; transient = -2; }
+    break;
+
+  case 160:
+#line 1282 "soapcpp2_yacc.y"
+    { (yyval.sto) = Snone; }
+    break;
+
+  case 161:
+#line 1283 "soapcpp2_yacc.y"
+    { (yyval.sto) = Sconstobj; }
+    break;
+
+  case 162:
+#line 1285 "soapcpp2_yacc.y"
+    { (yyval.sto) = Snone; }
+    break;
+
+  case 163:
+#line 1286 "soapcpp2_yacc.y"
+    { (yyval.sto) = Sabstract; }
+    break;
+
+  case 164:
+#line 1288 "soapcpp2_yacc.y"
+    { (yyval.sto) = Snone; }
+    break;
+
+  case 165:
+#line 1289 "soapcpp2_yacc.y"
+    { (yyval.sto) = Svirtual; }
+    break;
+
+  case 166:
+#line 1291 "soapcpp2_yacc.y"
+    { (yyval.rec) = tmp = sp->node; }
+    break;
+
+  case 167:
+#line 1292 "soapcpp2_yacc.y"
+    { /* handle const pointers, such as const char* */
+			  if (/*tmp.typ->type == Tchar &&*/ (tmp.sto & Sconst))
+			  	tmp.sto = (tmp.sto & ~Sconst) | Sconstptr;
+			  tmp.typ = mkpointer(tmp.typ);
+			  tmp.typ->transient = transient;
+			  (yyval.rec) = tmp;
+			}
+    break;
+
+  case 168:
+#line 1299 "soapcpp2_yacc.y"
+    { tmp.typ = mkreference(tmp.typ);
+			  tmp.typ->transient = transient;
+			  (yyval.rec) = tmp;
+			}
+    break;
+
+  case 169:
+#line 1304 "soapcpp2_yacc.y"
+    { (yyval.rec) = tmp;	/* tmp is inherited */
+			}
+    break;
+
+  case 170:
+#line 1307 "soapcpp2_yacc.y"
+    { if ((yyvsp[(4) - (4)].rec).typ->type == Tchar)
+			  {	sprintf(errbuf, "char["SOAP_LONG_FORMAT"] will be encoded as an array of "SOAP_LONG_FORMAT" bytes: use char* for strings", (yyvsp[(2) - (4)].rec).val.i, (yyvsp[(2) - (4)].rec).val.i);
+			  	semwarn(errbuf);
+			  }
+			  if ((yyvsp[(2) - (4)].rec).hasval && (yyvsp[(2) - (4)].rec).typ->type == Tint && (yyvsp[(2) - (4)].rec).val.i > 0 && (yyvsp[(4) - (4)].rec).typ->width > 0)
+				(yyval.rec).typ = mkarray((yyvsp[(4) - (4)].rec).typ, (int) (yyvsp[(2) - (4)].rec).val.i * (yyvsp[(4) - (4)].rec).typ->width);
+			  else
+			  {	(yyval.rec).typ = mkarray((yyvsp[(4) - (4)].rec).typ, 0);
+			  	semerror("undetermined array size");
+			  }
+			  (yyval.rec).sto = (yyvsp[(4) - (4)].rec).sto;
+			}
+    break;
+
+  case 171:
+#line 1319 "soapcpp2_yacc.y"
+    { (yyval.rec).typ = mkpointer((yyvsp[(3) - (3)].rec).typ); /* zero size array = pointer */
+			  (yyval.rec).sto = (yyvsp[(3) - (3)].rec).sto;
+			}
+    break;
+
+  case 172:
+#line 1323 "soapcpp2_yacc.y"
+    { if ((yyvsp[(1) - (1)].rec).typ->type == Tstruct || (yyvsp[(1) - (1)].rec).typ->type == Tclass)
+				if (!(yyvsp[(1) - (1)].rec).typ->ref && !(yyvsp[(1) - (1)].rec).typ->transient && !((yyvsp[(1) - (1)].rec).sto & Stypedef))
+			   	{	sprintf(errbuf, "struct/class '%s' has incomplete type", (yyvsp[(1) - (1)].rec).typ->id->name);
+					semerror(errbuf);
+				}
+			  (yyval.rec) = (yyvsp[(1) - (1)].rec);
+			}
+    break;
+
+  case 173:
+#line 1331 "soapcpp2_yacc.y"
+    { (yyval.rec).hasval = False; }
+    break;
+
+  case 174:
+#line 1332 "soapcpp2_yacc.y"
+    { if ((yyvsp[(2) - (2)].rec).hasval)
+			  {	(yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ;
+				(yyval.rec).hasval = True;
+				(yyval.rec).val = (yyvsp[(2) - (2)].rec).val;
+			  }
+			  else
+			  {	(yyval.rec).hasval = False;
+				semerror("initialization expression not constant");
+			  }
+			}
+    break;
+
+  case 175:
+#line 1344 "soapcpp2_yacc.y"
+    { (yyval.rec).minOccurs = -1;
+			  (yyval.rec).maxOccurs = 1;
+			  (yyval.rec).pattern = (yyvsp[(1) - (1)].s);
+			}
+    break;
+
+  case 176:
+#line 1349 "soapcpp2_yacc.y"
+    { (yyval.rec).minOccurs = (long)(yyvsp[(2) - (2)].i);
+			  (yyval.rec).maxOccurs = 1;
+			  (yyval.rec).pattern = (yyvsp[(1) - (2)].s);
+			}
+    break;
+
+  case 177:
+#line 1354 "soapcpp2_yacc.y"
+    { (yyval.rec).minOccurs = (long)(yyvsp[(2) - (3)].i);
+			  (yyval.rec).maxOccurs = 1;
+			  (yyval.rec).pattern = (yyvsp[(1) - (3)].s);
+			}
+    break;
+
+  case 178:
+#line 1359 "soapcpp2_yacc.y"
+    { (yyval.rec).minOccurs = (long)(yyvsp[(2) - (4)].i);
+			  (yyval.rec).maxOccurs = (long)(yyvsp[(4) - (4)].i);
+			  (yyval.rec).pattern = (yyvsp[(1) - (4)].s);
+			}
+    break;
+
+  case 179:
+#line 1364 "soapcpp2_yacc.y"
+    { (yyval.rec).minOccurs = -1;
+			  (yyval.rec).maxOccurs = (long)(yyvsp[(3) - (3)].i);
+			  (yyval.rec).pattern = (yyvsp[(1) - (3)].s);
+			}
+    break;
+
+  case 180:
+#line 1369 "soapcpp2_yacc.y"
+    { (yyval.s) = NULL; }
+    break;
+
+  case 181:
+#line 1370 "soapcpp2_yacc.y"
+    { (yyval.s) = (yyvsp[(1) - (1)].s); }
+    break;
+
+  case 182:
+#line 1372 "soapcpp2_yacc.y"
+    { (yyval.i) = (yyvsp[(1) - (1)].i); }
+    break;
+
+  case 183:
+#line 1373 "soapcpp2_yacc.y"
+    { (yyval.i) = (yyvsp[(2) - (2)].i); }
+    break;
+
+  case 184:
+#line 1374 "soapcpp2_yacc.y"
+    { (yyval.i) = -(yyvsp[(2) - (2)].i); }
+    break;
+
+  case 185:
+#line 1383 "soapcpp2_yacc.y"
+    { (yyval.rec) = (yyvsp[(3) - (3)].rec); }
+    break;
+
+  case 186:
+#line 1384 "soapcpp2_yacc.y"
+    { (yyval.rec) = (yyvsp[(1) - (1)].rec); }
+    break;
+
+  case 187:
+#line 1388 "soapcpp2_yacc.y"
+    { (yyval.rec).typ = (yyvsp[(3) - (5)].rec).typ;
+			  (yyval.rec).sto = Snone;
+			  (yyval.rec).hasval = False;
+			}
+    break;
+
+  case 189:
+#line 1395 "soapcpp2_yacc.y"
+    { (yyval.rec) = (yyvsp[(1) - (1)].rec); }
+    break;
+
+  case 190:
+#line 1398 "soapcpp2_yacc.y"
+    { (yyval.rec).hasval = False;
+			  (yyval.rec).typ = mkint();
+			}
+    break;
+
+  case 191:
+#line 1401 "soapcpp2_yacc.y"
+    { (yyval.rec) = (yyvsp[(1) - (1)].rec); }
+    break;
+
+  case 192:
+#line 1403 "soapcpp2_yacc.y"
+    { (yyval.rec) = (yyvsp[(1) - (1)].rec); }
+    break;
+
+  case 193:
+#line 1406 "soapcpp2_yacc.y"
+    { (yyval.rec).hasval = False;
+			  (yyval.rec).typ = mkint();
+			}
+    break;
+
+  case 194:
+#line 1409 "soapcpp2_yacc.y"
+    { (yyval.rec) = (yyvsp[(1) - (1)].rec); }
+    break;
+
+  case 195:
+#line 1411 "soapcpp2_yacc.y"
+    { (yyval.rec) = (yyvsp[(1) - (1)].rec); }
+    break;
+
+  case 196:
+#line 1414 "soapcpp2_yacc.y"
+    { (yyval.rec) = iop("|", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 197:
+#line 1415 "soapcpp2_yacc.y"
+    { (yyval.rec) = iop("^", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 198:
+#line 1416 "soapcpp2_yacc.y"
+    { (yyval.rec) = iop("&", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 199:
+#line 1417 "soapcpp2_yacc.y"
+    { (yyval.rec) = relop("==", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 200:
+#line 1418 "soapcpp2_yacc.y"
+    { (yyval.rec) = relop("!=", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 201:
+#line 1419 "soapcpp2_yacc.y"
+    { (yyval.rec) = relop("<", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 202:
+#line 1420 "soapcpp2_yacc.y"
+    { (yyval.rec) = relop("<=", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 203:
+#line 1421 "soapcpp2_yacc.y"
+    { (yyval.rec) = relop(">", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 204:
+#line 1422 "soapcpp2_yacc.y"
+    { (yyval.rec) = relop(">=", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 205:
+#line 1423 "soapcpp2_yacc.y"
+    { (yyval.rec) = iop("<<", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 206:
+#line 1424 "soapcpp2_yacc.y"
+    { (yyval.rec) = iop(">>", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 207:
+#line 1425 "soapcpp2_yacc.y"
+    { (yyval.rec) = op("+", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 208:
+#line 1426 "soapcpp2_yacc.y"
+    { (yyval.rec) = op("-", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 209:
+#line 1427 "soapcpp2_yacc.y"
+    { (yyval.rec) = op("*", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 210:
+#line 1428 "soapcpp2_yacc.y"
+    { (yyval.rec) = op("/", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 211:
+#line 1429 "soapcpp2_yacc.y"
+    { (yyval.rec) = iop("%", (yyvsp[(1) - (3)].rec), (yyvsp[(3) - (3)].rec)); }
+    break;
+
+  case 212:
+#line 1430 "soapcpp2_yacc.y"
+    { (yyval.rec) = (yyvsp[(1) - (1)].rec); }
+    break;
+
+  case 213:
+#line 1433 "soapcpp2_yacc.y"
+    { if ((yyvsp[(2) - (2)].rec).hasval)
+				(yyval.rec).val.i = !(yyvsp[(2) - (2)].rec).val.i;
+			  (yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ;
+			  (yyval.rec).hasval = (yyvsp[(2) - (2)].rec).hasval;
+			}
+    break;
+
+  case 214:
+#line 1438 "soapcpp2_yacc.y"
+    { if ((yyvsp[(2) - (2)].rec).hasval)
+				(yyval.rec).val.i = ~(yyvsp[(2) - (2)].rec).val.i;
+			  (yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ;
+			  (yyval.rec).hasval = (yyvsp[(2) - (2)].rec).hasval;
+			}
+    break;
+
+  case 215:
+#line 1443 "soapcpp2_yacc.y"
+    { if ((yyvsp[(2) - (2)].rec).hasval) {
+				if (integer((yyvsp[(2) - (2)].rec).typ))
+					(yyval.rec).val.i = -(yyvsp[(2) - (2)].rec).val.i;
+				else if (real((yyvsp[(2) - (2)].rec).typ))
+					(yyval.rec).val.r = -(yyvsp[(2) - (2)].rec).val.r;
+				else	typerror("string?");
+			  }
+			  (yyval.rec).typ = (yyvsp[(2) - (2)].rec).typ;
+			  (yyval.rec).hasval = (yyvsp[(2) - (2)].rec).hasval;
+			}
+    break;
+
+  case 216:
+#line 1453 "soapcpp2_yacc.y"
+    { (yyval.rec) = (yyvsp[(2) - (2)].rec); }
+    break;
+
+  case 217:
+#line 1454 "soapcpp2_yacc.y"
+    { if ((yyvsp[(2) - (2)].rec).typ->type == Tpointer) {
+			  	(yyval.rec).typ = (Tnode*) (yyvsp[(2) - (2)].rec).typ->ref;
+			  } else
+			  	typerror("dereference of non-pointer type");
+			  (yyval.rec).sto = Snone;
+			  (yyval.rec).hasval = False;
+			}
+    break;
+
+  case 218:
+#line 1461 "soapcpp2_yacc.y"
+    { (yyval.rec).typ = mkpointer((yyvsp[(2) - (2)].rec).typ);
+			  (yyval.rec).sto = Snone;
+			  (yyval.rec).hasval = False;
+			}
+    break;
+
+  case 219:
+#line 1466 "soapcpp2_yacc.y"
+    { (yyval.rec).hasval = True;
+			  (yyval.rec).typ = mkint();
+			  (yyval.rec).val.i = (yyvsp[(3) - (4)].rec).typ->width;
+			}
+    break;
+
+  case 220:
+#line 1470 "soapcpp2_yacc.y"
+    { (yyval.rec) = (yyvsp[(1) - (1)].rec); }
+    break;
+
+  case 221:
+#line 1473 "soapcpp2_yacc.y"
+    { (yyval.rec) = (yyvsp[(2) - (3)].rec); }
+    break;
+
+  case 222:
+#line 1474 "soapcpp2_yacc.y"
+    { if ((p = enumentry((yyvsp[(1) - (1)].sym))) == (Entry*) 0)
+				p = undefined((yyvsp[(1) - (1)].sym));
+			  else
+			  	(yyval.rec).hasval = True;
+			  (yyval.rec).typ = p->info.typ;
+			  (yyval.rec).val = p->info.val;
+			}
+    break;
+
+  case 223:
+#line 1481 "soapcpp2_yacc.y"
+    { (yyval.rec).typ = mkint();
+			  (yyval.rec).hasval = True;
+			  (yyval.rec).val.i = (yyvsp[(1) - (1)].i);
+			}
+    break;
+
+  case 224:
+#line 1485 "soapcpp2_yacc.y"
+    { (yyval.rec).typ = mkint();
+			  (yyval.rec).hasval = True;
+			  (yyval.rec).val.i = 0;
+			}
+    break;
+
+  case 225:
+#line 1489 "soapcpp2_yacc.y"
+    { (yyval.rec).typ = mkfloat();
+			  (yyval.rec).hasval = True;
+			  (yyval.rec).val.r = (yyvsp[(1) - (1)].r);
+			}
+    break;
+
+  case 226:
+#line 1493 "soapcpp2_yacc.y"
+    { (yyval.rec).typ = mkchar();
+			  (yyval.rec).hasval = True;
+			  (yyval.rec).val.i = (yyvsp[(1) - (1)].c);
+			}
+    break;
+
+  case 227:
+#line 1497 "soapcpp2_yacc.y"
+    { (yyval.rec).typ = mkstring();
+			  (yyval.rec).hasval = True;
+			  (yyval.rec).val.s = (yyvsp[(1) - (1)].s);
+			}
+    break;
+
+  case 228:
+#line 1501 "soapcpp2_yacc.y"
+    { (yyval.rec).typ = mkbool();
+			  (yyval.rec).hasval = True;
+			  (yyval.rec).val.i = 0;
+			}
+    break;
+
+  case 229:
+#line 1505 "soapcpp2_yacc.y"
+    { (yyval.rec).typ = mkbool();
+			  (yyval.rec).hasval = True;
+			  (yyval.rec).val.i = 1;
+			}
+    break;
+
+
+/* Line 1267 of yacc.c.  */
+#line 4143 "soapcpp2_yacc.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse look-ahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+#line 1511 "soapcpp2_yacc.y"
+
+
+/*
+ * ???
+ */
+int
+yywrap()
+{	return 1;
+}
+
+/******************************************************************************\
+
+	Support routines
+
+\******************************************************************************/
+
+static Node
+op(const char *op, Node p, Node q)
+{	Node	r;
+	Tnode	*typ;
+	r.typ = p.typ;
+	r.sto = Snone;
+	if (p.hasval && q.hasval) {
+		if (integer(p.typ) && integer(q.typ))
+			switch (op[0]) {
+			case '|':	r.val.i = p.val.i |  q.val.i; break;
+			case '^':	r.val.i = p.val.i ^  q.val.i; break;
+			case '&':	r.val.i = p.val.i &  q.val.i; break;
+			case '<':	r.val.i = p.val.i << q.val.i; break;
+			case '>':	r.val.i = p.val.i >> q.val.i; break;
+			case '+':	r.val.i = p.val.i +  q.val.i; break;
+			case '-':	r.val.i = p.val.i -  q.val.i; break;
+			case '*':	r.val.i = p.val.i *  q.val.i; break;
+			case '/':	r.val.i = p.val.i /  q.val.i; break;
+			case '%':	r.val.i = p.val.i %  q.val.i; break;
+			default:	typerror(op);
+			}
+		else if (real(p.typ) && real(q.typ))
+			switch (op[0]) {
+			case '+':	r.val.r = p.val.r + q.val.r; break;
+			case '-':	r.val.r = p.val.r - q.val.r; break;
+			case '*':	r.val.r = p.val.r * q.val.r; break;
+			case '/':	r.val.r = p.val.r / q.val.r; break;
+			default:	typerror(op);
+			}
+		else	semerror("illegal constant operation");
+		r.hasval = True;
+	} else {
+		typ = mgtype(p.typ, q.typ);
+		r.hasval = False;
+	}
+	return r;
+}
+
+static Node
+iop(const char *iop, Node p, Node q)
+{	if (integer(p.typ) && integer(q.typ))
+		return op(iop, p, q);
+	typerror("integer operands only");
+	return p;
+}
+
+static Node
+relop(const char *op, Node p, Node q)
+{	Node	r;
+	Tnode	*typ;
+	r.typ = mkint();
+	r.sto = Snone;
+	r.hasval = False;
+	if (p.typ->type != Tpointer || p.typ != q.typ)
+		typ = mgtype(p.typ, q.typ);
+	return r;
+}
+
+/******************************************************************************\
+
+	Scope management
+
+\******************************************************************************/
+
+/*
+mkscope - initialize scope stack with a new table and offset
+*/
+static void
+mkscope(Table *table, int offset)
+{	sp = stack-1;
+	enterscope(table, offset);
+}
+
+/*
+enterscope - enter a new scope by pushing a new table and offset on the stack
+*/
+static void
+enterscope(Table *table, int offset)
+{	if (++sp == stack+MAXNEST)
+		execerror("maximum scope depth exceeded");
+	sp->table = table;
+	sp->val = 0;
+	sp->offset = offset;
+	sp->grow = True;	/* by default, offset grows */
+	sp->mask = False;
+}
+
+/*
+exitscope - exit a scope by popping the table and offset from the stack
+*/
+static void
+exitscope()
+{	check(sp-- != stack, "exitscope() has no matching enterscope()");
+}
+
+/******************************************************************************\
+
+	Undefined symbol
+
+\******************************************************************************/
+
+static Entry*
+undefined(Symbol *sym)
+{	Entry	*p;
+	sprintf(errbuf, "undefined identifier '%s'", sym->name);
+	semwarn(errbuf);
+	p = enter(sp->table, sym);
+	p->level = GLOBAL;
+	p->info.typ = mkint();
+	p->info.sto = Sextern;
+	p->info.hasval = False;
+	return p;
+}
+
+/*
+mgtype - return most general type among two numerical types
+*/
+Tnode*
+mgtype(Tnode *typ1, Tnode *typ2)
+{	if (numeric(typ1) && numeric(typ2)) {
+		if (typ1->type < typ2->type)
+			return typ2;
+	} else	typerror("non-numeric type");
+	return typ1;
+}
+
+/******************************************************************************\
+
+	Type checks
+
+\******************************************************************************/
+
+static int
+integer(Tnode *typ)
+{	switch (typ->type) {
+	case Tchar:
+	case Tshort:
+	case Tint:
+	case Tlong:	return True;
+	default:	break;
+	}
+	return False;
+}
+
+static int
+real(Tnode *typ)
+{	switch (typ->type) {
+	case Tfloat:
+	case Tdouble:
+	case Tldouble:	return True;
+	default:	break;
+	}
+	return False;
+}
+
+static int
+numeric(Tnode *typ)
+{	return integer(typ) || real(typ);
+}
+
+static void
+add_fault(Table *gt)
+{ Table *t;
+  Entry *p1, *p2, *p3, *p4;
+  Symbol *s1, *s2, *s3, *s4;
+  imported = NULL;
+  s1 = lookup("SOAP_ENV__Code");
+  p1 = entry(classtable, s1);
+  if (!p1 || !p1->info.typ->ref)
+  { t = mktable((Table*)0);
+    if (!p1)
+    { p1 = enter(classtable, s1);
+      p1->info.typ = mkstruct(t, 3*4);
+      p1->info.typ->id = s1;
+    }
+    else
+      p1->info.typ->ref = t;
+    p2 = enter(t, lookup("SOAP_ENV__Value"));
+    p2->info.typ = qname;
+    p2->info.minOccurs = 0;
+    p2 = enter(t, lookup("SOAP_ENV__Subcode"));
+    p2->info.typ = mkpointer(p1->info.typ);
+    p2->info.minOccurs = 0;
+  }
+  s2 = lookup("SOAP_ENV__Detail");
+  p2 = entry(classtable, s2);
+  if (!p2 || !p2->info.typ->ref)
+  { t = mktable((Table*)0);
+    if (!p2)
+    { p2 = enter(classtable, s2);
+      p2->info.typ = mkstruct(t, 3*4);
+      p2->info.typ->id = s2;
+    }
+    else
+      p2->info.typ->ref = t;
+    p3 = enter(t, lookup("__type"));
+    p3->info.typ = mkint();
+    p3->info.minOccurs = 0;
+    p3 = enter(t, lookup("fault"));
+    p3->info.typ = mkpointer(mkvoid());
+    p3->info.minOccurs = 0;
+    p3 = enter(t, lookup("__any"));
+    p3->info.typ = xml;
+    p3->info.minOccurs = 0;
+    custom_fault = 0;
+  }
+  s4 = lookup("SOAP_ENV__Reason");
+  p4 = entry(classtable, s4);
+  if (!p4 || !p4->info.typ->ref)
+  { t = mktable((Table*)0);
+    if (!p4)
+    { p4 = enter(classtable, s4);
+      p4->info.typ = mkstruct(t, 4);
+      p4->info.typ->id = s4;
+    }
+    else
+      p4->info.typ->ref = t;
+    p3 = enter(t, lookup("SOAP_ENV__Text"));
+    p3->info.typ = mkstring();
+    p3->info.minOccurs = 0;
+  }
+  s3 = lookup("SOAP_ENV__Fault");
+  p3 = entry(classtable, s3);
+  if (!p3 || !p3->info.typ->ref)
+  { t = mktable(NULL);
+    if (!p3)
+    { p3 = enter(classtable, s3);
+      p3->info.typ = mkstruct(t, 9*4);
+      p3->info.typ->id = s3;
+    }
+    else
+      p3->info.typ->ref = t;
+    p3 = enter(t, lookup("faultcode"));
+    p3->info.typ = qname;
+    p3->info.minOccurs = 0;
+    p3 = enter(t, lookup("faultstring"));
+    p3->info.typ = mkstring();
+    p3->info.minOccurs = 0;
+    p3 = enter(t, lookup("faultactor"));
+    p3->info.typ = mkstring();
+    p3->info.minOccurs = 0;
+    p3 = enter(t, lookup("detail"));
+    p3->info.typ = mkpointer(p2->info.typ);
+    p3->info.minOccurs = 0;
+    p3 = enter(t, s1);
+    p3->info.typ = mkpointer(p1->info.typ);
+    p3->info.minOccurs = 0;
+    p3 = enter(t, s4);
+    p3->info.typ = mkpointer(p4->info.typ);
+    p3->info.minOccurs = 0;
+    p3 = enter(t, lookup("SOAP_ENV__Node"));
+    p3->info.typ = mkstring();
+    p3->info.minOccurs = 0;
+    p3 = enter(t, lookup("SOAP_ENV__Role"));
+    p3->info.typ = mkstring();
+    p3->info.minOccurs = 0;
+    p3 = enter(t, lookup("SOAP_ENV__Detail"));
+    p3->info.typ = mkpointer(p2->info.typ);
+    p3->info.minOccurs = 0;
+  }
+}
+
+static void
+add_soap()
+{ Symbol *s = lookup("soap");
+  p = enter(classtable, s);
+  p->info.typ = mkstruct(NULL, 0);
+  p->info.typ->transient = -2;
+  p->info.typ->id = s;
+}
+
+static void
+add_XML()
+{ Symbol *s = lookup("_XML");
+  p = enter(typetable, s);
+  xml = p->info.typ = mksymtype(mkstring(), s);
+  p->info.sto = Stypedef;
+}
+
+static void
+add_qname()
+{ Symbol *s = lookup("_QName");
+  p = enter(typetable, s);
+  qname = p->info.typ = mksymtype(mkstring(), s);
+  p->info.sto = Stypedef;
+}
+
+static void
+add_header(Table *gt)
+{ Table *t;
+  Entry *p;
+  Symbol *s = lookup("SOAP_ENV__Header");
+  imported = NULL;
+  p = entry(classtable, s);
+  if (!p || !p->info.typ->ref)
+  { t = mktable((Table*)0);
+    if (!p)
+      p = enter(classtable, s);
+    p->info.typ = mkstruct(t, 0);
+    p->info.typ->id = s;
+    custom_header = 0;
+  }
+}
+
+static void
+add_response(Entry *fun, Entry *ret)
+{ Table *t;
+  Entry *p, *q;
+  Symbol *s;
+  size_t n = strlen(fun->sym->name);
+  char *r = (char*)emalloc(n+9);
+  strcpy(r, fun->sym->name);
+  strcat(r, "Response");
+  if (!(s = lookup(r)))
+    s = install(r, ID);
+  free(r);
+  t = mktable((Table*)0);
+  q = enter(t, ret->sym);
+  q->info = ret->info;
+  if (q->info.typ->type == Treference)
+    q->info.typ = (Tnode*)q->info.typ->ref;
+  p = enter(classtable, s);
+  p->info.typ = mkstruct(t, 4);
+  p->info.typ->id = s;
+  fun->info.typ->response = p;
+}
+
+static void
+add_result(Tnode *typ)
+{ Entry *p;
+  if (!typ->ref || !((Tnode*)typ->ref)->ref)
+  { semwarn("response struct/class must be declared before used in function prototype");
+    return;
+  }
+  for (p = ((Table*)((Tnode*)typ->ref)->ref)->list; p; p = p->next)
+    if (p->info.sto & Sreturn)
+      return;
+  for (p = ((Table*)((Tnode*)typ->ref)->ref)->list; p; p = p->next)
+  { if (p->info.typ->type != Tfun && !(p->info.sto & Sattribute) && !is_transient(p->info.typ) && !(p->info.sto & (Sprivate|Sprotected)))
+      p->info.sto = (Storage)((int)p->info.sto | (int)Sreturn);
+      return;
+  }
+}
+
diff -urN d/gsoap/src/soapcpp2_yacc.h e/gsoap/src/soapcpp2_yacc.h
--- d/gsoap/src/soapcpp2_yacc.h	1970-01-01 01:00:00.000000000 +0100
+++ e/gsoap/src/soapcpp2_yacc.h	2010-01-24 11:59:32.000000000 +0100
@@ -0,0 +1,243 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     PRAGMA = 258,
+     AUTO = 259,
+     DOUBLE = 260,
+     INT = 261,
+     STRUCT = 262,
+     BREAK = 263,
+     ELSE = 264,
+     LONG = 265,
+     SWITCH = 266,
+     CASE = 267,
+     ENUM = 268,
+     REGISTER = 269,
+     TYPEDEF = 270,
+     CHAR = 271,
+     EXTERN = 272,
+     RETURN = 273,
+     UNION = 274,
+     CONST = 275,
+     FLOAT = 276,
+     SHORT = 277,
+     UNSIGNED = 278,
+     CONTINUE = 279,
+     FOR = 280,
+     SIGNED = 281,
+     VOID = 282,
+     DEFAULT = 283,
+     GOTO = 284,
+     SIZEOF = 285,
+     VOLATILE = 286,
+     DO = 287,
+     IF = 288,
+     STATIC = 289,
+     WHILE = 290,
+     CLASS = 291,
+     PRIVATE = 292,
+     PROTECTED = 293,
+     PUBLIC = 294,
+     VIRTUAL = 295,
+     INLINE = 296,
+     OPERATOR = 297,
+     LLONG = 298,
+     BOOL = 299,
+     CFALSE = 300,
+     CTRUE = 301,
+     WCHAR = 302,
+     TIME = 303,
+     USING = 304,
+     NAMESPACE = 305,
+     ULLONG = 306,
+     MUSTUNDERSTAND = 307,
+     SIZE = 308,
+     FRIEND = 309,
+     TEMPLATE = 310,
+     EXPLICIT = 311,
+     TYPENAME = 312,
+     RESTRICT = 313,
+     null = 314,
+     NONE = 315,
+     ID = 316,
+     LAB = 317,
+     TYPE = 318,
+     LNG = 319,
+     DBL = 320,
+     CHR = 321,
+     STR = 322,
+     RA = 323,
+     LA = 324,
+     OA = 325,
+     XA = 326,
+     AA = 327,
+     MA = 328,
+     DA = 329,
+     TA = 330,
+     NA = 331,
+     PA = 332,
+     OR = 333,
+     AN = 334,
+     NE = 335,
+     EQ = 336,
+     GE = 337,
+     LE = 338,
+     RS = 339,
+     LS = 340,
+     AR = 341,
+     PP = 342,
+     NN = 343
+   };
+#endif
+/* Tokens.  */
+#define PRAGMA 258
+#define AUTO 259
+#define DOUBLE 260
+#define INT 261
+#define STRUCT 262
+#define BREAK 263
+#define ELSE 264
+#define LONG 265
+#define SWITCH 266
+#define CASE 267
+#define ENUM 268
+#define REGISTER 269
+#define TYPEDEF 270
+#define CHAR 271
+#define EXTERN 272
+#define RETURN 273
+#define UNION 274
+#define CONST 275
+#define FLOAT 276
+#define SHORT 277
+#define UNSIGNED 278
+#define CONTINUE 279
+#define FOR 280
+#define SIGNED 281
+#define VOID 282
+#define DEFAULT 283
+#define GOTO 284
+#define SIZEOF 285
+#define VOLATILE 286
+#define DO 287
+#define IF 288
+#define STATIC 289
+#define WHILE 290
+#define CLASS 291
+#define PRIVATE 292
+#define PROTECTED 293
+#define PUBLIC 294
+#define VIRTUAL 295
+#define INLINE 296
+#define OPERATOR 297
+#define LLONG 298
+#define BOOL 299
+#define CFALSE 300
+#define CTRUE 301
+#define WCHAR 302
+#define TIME 303
+#define USING 304
+#define NAMESPACE 305
+#define ULLONG 306
+#define MUSTUNDERSTAND 307
+#define SIZE 308
+#define FRIEND 309
+#define TEMPLATE 310
+#define EXPLICIT 311
+#define TYPENAME 312
+#define RESTRICT 313
+#define null 314
+#define NONE 315
+#define ID 316
+#define LAB 317
+#define TYPE 318
+#define LNG 319
+#define DBL 320
+#define CHR 321
+#define STR 322
+#define RA 323
+#define LA 324
+#define OA 325
+#define XA 326
+#define AA 327
+#define MA 328
+#define DA 329
+#define TA 330
+#define NA 331
+#define PA 332
+#define OR 333
+#define AN 334
+#define NE 335
+#define EQ 336
+#define GE 337
+#define LE 338
+#define RS 339
+#define LS 340
+#define AR 341
+#define PP 342
+#define NN 343
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+#line 135 "soapcpp2_yacc.y"
+{	Symbol	*sym;
+	LONG64	i;
+	double	r;
+	char	c;
+	char	*s;
+	Tnode	*typ;
+	Storage	sto;
+	Node	rec;
+	Entry	*e;
+}
+/* Line 1489 of yacc.c.  */
+#line 236 "soapcpp2_yacc.h"
+	YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+extern YYSTYPE yylval;
+
