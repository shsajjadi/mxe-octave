diff -r c570624ba1cd src/packfields.cc
--- a/src/packfields.cc	Thu Jul 20 13:15:55 2017 -0400
+++ b/src/packfields.cc	Thu Jul 20 13:36:57 2017 -0400
@@ -15,10 +15,15 @@
 
 #include <octave/oct.h>
 #include <octave/utils.h>
+#include <octave/interpreter.h>
 #include <octave/symtab.h>
 #include <octave/oct-map.h>
 
+#ifdef DEFMETHOD_DLD
+DEFMETHOD_DLD (packfields, interp, args, ,
+#else
 DEFUN_DLD (packfields, args, ,
+#endif
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} packfields (@var{s_name}, @var{var1}, @var{var2}, @dots{})\n\
 Create struct from variables.\n\
@@ -44,6 +49,11 @@
 
   if (nargin > 0)
     {
+#ifdef DEFMETHOD_DLD
+      octave::symbol_table::scope *curr_scope
+       = interp.require_current_scope ("packfields");
+#endif
+
       std::string struct_name = args (0).string_value ();
       string_vector fld_names(nargin-1);
       octave_value_list fld_vals(nargin-1);
@@ -64,7 +74,12 @@
           if (valid_identifier (fld_name))
             {
               fld_names(i) = fld_name;
+
+#ifdef DEFMETHOD_DLD
+              octave_value fld_val = curr_scope->varval (fld_name);
+#else
               octave_value fld_val = symbol_table::varval (fld_name);
+#endif
               if (fld_val.is_defined ())
                 fld_vals(i) = fld_val;
               else
@@ -77,8 +92,11 @@
       if (! error_state)
         {
           // Force the symbol to be inserted in caller's scope.
+#ifdef DEFMETHOD_DLD
+          octave::symbol_table::symbol_record& rec = curr_scope->insert (struct_name);
+#else
           symbol_table::symbol_record& rec = symbol_table::insert (struct_name);
-
+#endif
           octave_value& struct_ref = rec.varref ();
 
           // If not defined, use struct ().
diff -r c570624ba1cd src/unpackfields.cc
--- a/src/unpackfields.cc	Thu Jul 20 13:15:55 2017 -0400
+++ b/src/unpackfields.cc	Thu Jul 20 13:36:57 2017 -0400
@@ -15,10 +15,15 @@
 
 #include <octave/oct.h>
 #include <octave/utils.h>
+#include <octave/interpreter.h>
 #include <octave/symtab.h>
 #include <octave/oct-map.h>
 
+#ifdef DEFMETHOD_DLD
+DEFMETHOD_DLD (packfields, interp, args, ,
+#else
 DEFUN_DLD (unpackfields, args, ,
+#endif
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} unpackfields (@var{s_name}, @var{fld1}, @var{fld2}, @dots{})\n\
 Create variables from fields of a struct.\n\
@@ -50,6 +55,11 @@
 
   if (nargin > 0)
     {
+#ifdef DEFMETHOD_DLD
+      octave::symbol_table::scope *curr_scope
+       = interp.require_current_scope ("unpackfields");
+#endif
+
       std::string struct_name = args (0).string_value ();
       string_vector fld_names(nargin-1);
 
@@ -75,8 +85,11 @@
       if (! error_state)
         {
           // Force the symbol to be inserted in caller's scope.
+#ifdef DEFMETHOD_DLD
+          octave_value struct_val = curr_scope->varval (struct_name);
+#else
           octave_value struct_val = symbol_table::varval (struct_name);
-
+#endif
           if (struct_val.is_map ())
             {
               // Fast code for a built-in struct.
@@ -89,7 +102,11 @@
                     {
                       octave_scalar_map::const_iterator iter = map.seek (fld_names(i));
                       if (iter != map.end ())
+#ifdef DEFMETHOD_DLD
+                        curr_scope->assign (fld_names(i), map.contents (iter));
+#else
                         symbol_table::assign (fld_names(i), map.contents (iter));
+#endif
                       else
                         {
                           error ("unpackfields: field %s does not exist", fld_names(i).c_str ());
@@ -114,7 +131,11 @@
                     break;
 
                   if (val.is_defined ())
+#ifdef DEFMETHOD_DLD
+                    curr_scope->assign (fld_names(i), val);
+#else
                     symbol_table::assign (fld_names(i), val);
+#endif
                 }
             }
         }
