diff -uNr a/src/packfields.cc b/src/packfields.cc
--- a/src/packfields.cc	2015-05-27 11:43:57.000000000 -0400
+++ b/src/packfields.cc	2017-12-07 15:09:12.838253308 -0500
@@ -15,10 +15,15 @@
 
 #include <octave/oct.h>
 #include <octave/utils.h>
+#include <octave/interpreter.h>
 #include <octave/symtab.h>
 #include <octave/oct-map.h>
 
+#ifdef DEFMETHOD_DLD
+DEFMETHOD_DLD (packfields, interp, args, ,
+#else
 DEFUN_DLD (packfields, args, ,
+#endif
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} packfields (@var{s_name}, @var{var1}, @var{var2}, @dots{})\n\
 Create struct from variables.\n\
@@ -44,6 +49,11 @@
 
   if (nargin > 0)
     {
+#ifdef DEFMETHOD_DLD
+      octave::symbol_table::scope curr_scope
+       = interp.require_current_scope ("packfields");
+#endif
+
       std::string struct_name = args (0).string_value ();
       string_vector fld_names(nargin-1);
       octave_value_list fld_vals(nargin-1);
@@ -64,7 +74,12 @@
           if (valid_identifier (fld_name))
             {
               fld_names(i) = fld_name;
+
+#ifdef DEFMETHOD_DLD
+              octave_value fld_val = curr_scope.varval (fld_name);
+#else
               octave_value fld_val = symbol_table::varval (fld_name);
+#endif
               if (fld_val.is_defined ())
                 fld_vals(i) = fld_val;
               else
@@ -76,46 +91,27 @@
 
       if (! error_state)
         {
-          // Force the symbol to be inserted in caller's scope.
-          symbol_table::symbol_record& rec = symbol_table::insert (struct_name);
-
-          octave_value& struct_ref = rec.varref ();
-
-          // If not defined, use struct ().
-          if (! struct_ref.is_defined ())
-            struct_ref = octave_scalar_map ();
-
-          if (struct_ref.is_map ())
-            {
-              // Fast code for a built-in struct.
-              octave_scalar_map map = struct_ref.scalar_map_value ();
-
-              if (! error_state)
-                {
-                  // Do the actual work.
-                  struct_ref = octave_value (); // Unshare map.
-                  for (octave_idx_type i = 0; i < nargin-1; i++)
-                    map.assign (fld_names(i), fld_vals(i));
-                  struct_ref = map;
-                }
-              else
-                error ("packfields: structure must have singleton dimensions");
-            }
-          else
-            {
-              // General case.
-              struct_ref.make_unique ();
-              std::list<octave_value_list> idx (1);
-
-              for (octave_idx_type i = 0; i < nargin-1; i++)
-                {
-                  idx.front () = args(i+1); // Save one string->octave_value conversion.
-                  struct_ref = struct_ref.subsasgn (".", idx, fld_vals (i));
-
-                  if (error_state)
-                    break;
-                }
-            }
+#ifdef DEFMETHOD_DLD
+          octave_value struct_val = curr_scope.varval (struct_name);
+#else
+          octave_value struct_val = symbol_table::varval (struct_name);
+#endif
+
+          octave_scalar_map map;
+
+          if (struct_val.is_defined () && struct_val.is_map ())
+            map = struct_val.scalar_map_value ();
+
+          for (octave_idx_type i = 0; i < nargin-1; i++)
+            map.assign (fld_names(i), fld_vals(i));
+
+          struct_val = map;
+
+#ifdef DEFMETHOD_DLD
+          curr_scope.assign (struct_name, struct_val);
+#else
+          symbol_table::assign (struct_name, struct_val);
+#endif
         }
     }
   else
diff -uNr a/src/unpackfields.cc b/src/unpackfields.cc
--- a/src/unpackfields.cc	2015-05-27 11:43:57.000000000 -0400
+++ b/src/unpackfields.cc	2017-12-07 15:09:12.842253124 -0500
@@ -15,10 +15,15 @@
 
 #include <octave/oct.h>
 #include <octave/utils.h>
+#include <octave/interpreter.h>
 #include <octave/symtab.h>
 #include <octave/oct-map.h>
 
+#ifdef DEFMETHOD_DLD
+DEFMETHOD_DLD (packfields, interp, args, ,
+#else
 DEFUN_DLD (unpackfields, args, ,
+#endif
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} unpackfields (@var{s_name}, @var{fld1}, @var{fld2}, @dots{})\n\
 Create variables from fields of a struct.\n\
@@ -50,6 +55,11 @@
 
   if (nargin > 0)
     {
+#ifdef DEFMETHOD_DLD
+      octave::symbol_table::scope curr_scope
+       = interp.require_current_scope ("unpackfields");
+#endif
+
       std::string struct_name = args (0).string_value ();
       string_vector fld_names(nargin-1);
 
@@ -75,8 +85,11 @@
       if (! error_state)
         {
           // Force the symbol to be inserted in caller's scope.
+#ifdef DEFMETHOD_DLD
+          octave_value struct_val = curr_scope.varval (struct_name);
+#else
           octave_value struct_val = symbol_table::varval (struct_name);
-
+#endif
           if (struct_val.is_map ())
             {
               // Fast code for a built-in struct.
@@ -89,7 +102,11 @@
                     {
                       octave_scalar_map::const_iterator iter = map.seek (fld_names(i));
                       if (iter != map.end ())
+#ifdef DEFMETHOD_DLD
+                        curr_scope.assign (fld_names(i), map.contents (iter));
+#else
                         symbol_table::assign (fld_names(i), map.contents (iter));
+#endif
                       else
                         {
                           error ("unpackfields: field %s does not exist", fld_names(i).c_str ());
@@ -114,7 +131,11 @@
                     break;
 
                   if (val.is_defined ())
+#ifdef DEFMETHOD_DLD
+                    curr_scope.assign (fld_names(i), val);
+#else
                     symbol_table::assign (fld_names(i), val);
+#endif
                 }
             }
         }
