diff -ur glib-2.48.1.orig/autogen.sh glib-2.48.1/autogen.sh
--- glib-2.48.1.orig/autogen.sh	2016-12-25 13:21:25.730080418 -0500
+++ glib-2.48.1/autogen.sh	2016-12-25 13:22:17.474289395 -0500
@@ -7,18 +7,6 @@
 olddir=`pwd`
 cd "$srcdir"
 
-GTKDOCIZE=$(which gtkdocize 2>/dev/null)
-if test -z $GTKDOCIZE; then
-        echo "You don't have gtk-doc installed, and thus won't be able to generate the documentation."
-        rm -f gtk-doc.make
-        cat > gtk-doc.make <<EOF
-EXTRA_DIST =
-CLEANFILES =
-EOF
-else
-        gtkdocize || exit $?
-fi
-
 AUTORECONF=`which autoreconf`
 if test -z $AUTORECONF; then
         echo "*** No autoreconf found, please install it ***"
diff -ur glib-2.48.1.orig/configure.ac glib-2.48.1/configure.ac
--- glib-2.48.1.orig/configure.ac	2016-12-25 13:21:25.725080302 -0500
+++ glib-2.48.1/configure.ac	2016-12-25 13:22:17.472289348 -0500
@@ -465,8 +465,8 @@
 GLIB_GNU_GETTEXT
 
 if test "$gt_cv_have_gettext" != "yes" ; then
-  AC_MSG_ERROR([
-*** You must have either have gettext support in your C library, or use the 
+  AC_MSG_WARN([
+*** You should have either have gettext support in your C library, or use the 
 *** GNU gettext library. (http://www.gnu.org/software/gettext/gettext.html
 ])
 fi
@@ -509,6 +509,8 @@
 dnl when using libtool 2.x create libtool early, because it's used in configure
 m4_ifdef([LT_OUTPUT], [LT_OUTPUT])
 
+# Make sure STDC_HEADERS is set for AC_CHECK_ALIGNOF
+AS_IF([false], [AC_CHECK_HEADER([stdint.h])])
 
 AS_IF([test "$glib_native_win32" = "yes"], [
   if test x$enable_static = xyes -a x$enable_shared = xyes; then
Only in glib-2.48.1: configure.ac.orig
Only in glib-2.48.1: configure.ac.rej
Only in glib-2.48.1/docs: Makefile.am.orig
Only in glib-2.48.1/docs: Makefile.am.rej
Only in glib-2.48.1/docs/reference/gio: gdbus-object-manager-example
Only in glib-2.48.1/docs/reference/gio: Makefile.am.orig
Only in glib-2.48.1/docs/reference/gio: Makefile.am.rej
Only in glib-2.48.1/docs/reference/glib: Makefile.am.orig
Only in glib-2.48.1/docs/reference/glib: Makefile.am.rej
Only in glib-2.48.1/docs/reference/gobject: Makefile.am.orig
Only in glib-2.48.1/docs/reference/gobject: Makefile.am.rej
Only in glib-2.48.1/docs/reference: Makefile.am.orig
Only in glib-2.48.1/docs/reference: Makefile.am.rej
diff -ur glib-2.48.1.orig/gio/giomodule.c glib-2.48.1/gio/giomodule.c
--- glib-2.48.1.orig/gio/giomodule.c	2016-12-25 13:21:25.751080909 -0500
+++ glib-2.48.1/gio/giomodule.c	2016-12-25 13:22:17.470289301 -0500
@@ -921,14 +921,12 @@
 
 static HMODULE gio_dll = NULL;
 
-#ifdef DLL_EXPORT
-
-BOOL WINAPI DllMain (HINSTANCE hinstDLL,
+BOOL WINAPI gio_DllMain (HINSTANCE hinstDLL,
                      DWORD     fdwReason,
                      LPVOID    lpvReserved);
 
 BOOL WINAPI
-DllMain (HINSTANCE hinstDLL,
+gio_DllMain (HINSTANCE hinstDLL,
 	 DWORD     fdwReason,
 	 LPVOID    lpvReserved)
 {
@@ -938,8 +936,6 @@
   return TRUE;
 }
 
-#endif
-
 void *
 _g_io_win32_get_module (void)
 {
Only in glib-2.48.1/gio: giomodule.c.orig
Only in glib-2.48.1: gio-2.0.pc.in.orig
Only in glib-2.48.1: gio-2.0.pc.in.rej
diff -ur glib-2.48.1.orig/glib/gi18n.h glib-2.48.1/glib/gi18n.h
--- glib-2.48.1.orig/glib/gi18n.h	2016-12-25 13:21:25.775081470 -0500
+++ glib-2.48.1/glib/gi18n.h	2016-12-25 13:22:17.469289278 -0500
@@ -20,7 +20,12 @@
 
 #include <glib.h>
 
+#ifdef ENABLE_NLS
 #include <libintl.h>
+#else
+#define gettext(String) (String)
+#endif
+
 #include <string.h>
 
 #define  _(String) gettext (String)
Only in glib-2.48.1/glib: gi18n.h.orig
diff -ur glib-2.48.1.orig/glib/glib-init.c glib-2.48.1/glib/glib-init.c
--- glib-2.48.1.orig/glib/glib-init.c	2016-12-25 13:21:25.780081587 -0500
+++ glib-2.48.1/glib/glib-init.c	2016-12-25 13:22:17.470289301 -0500
@@ -245,14 +245,14 @@
 
 #if defined (G_OS_WIN32)
 
-BOOL WINAPI DllMain (HINSTANCE hinstDLL,
+BOOL WINAPI glib_DllMain (HINSTANCE hinstDLL,
                      DWORD     fdwReason,
                      LPVOID    lpvReserved);
 
 HMODULE glib_dll;
 
 BOOL WINAPI
-DllMain (HINSTANCE hinstDLL,
+glib_DllMain (HINSTANCE hinstDLL,
          DWORD     fdwReason,
          LPVOID    lpvReserved)
 {
Only in glib-2.48.1/glib: glib-init.c.orig
diff -ur glib-2.48.1.orig/glib/gmain.c glib-2.48.1/glib/gmain.c
--- glib-2.48.1.orig/glib/gmain.c	2016-12-25 13:21:25.793081890 -0500
+++ glib-2.48.1/glib/gmain.c	2016-12-25 13:22:17.473289371 -0500
@@ -2609,12 +2609,15 @@
 #if defined (G_OS_WIN32)
 static ULONGLONG (*g_GetTickCount64) (void) = NULL;
 static guint32 g_win32_tick_epoch = 0;
+static gboolean g_win32_clock_is_initialized;
 
 void
 g_clock_win32_init (void)
 {
   HMODULE kernel32;
 
+  g_win32_clock_is_initialized = TRUE;
+
   g_GetTickCount64 = NULL;
   kernel32 = GetModuleHandle ("KERNEL32.DLL");
   if (kernel32 != NULL)
@@ -2673,6 +2676,9 @@
    *    timeBeginPeriod() to increase it as much as they want
    */
 
+  if (!g_win32_clock_is_initialized)
+    g_clock_win32_init ();
+
   if (g_GetTickCount64 != NULL)
     {
       guint32 ticks_as_32bit;
Only in glib-2.48.1/glib: gmain.c.orig
diff -ur glib-2.48.1.orig/glib/gstrfuncs.c glib-2.48.1/glib/gstrfuncs.c
--- glib-2.48.1.orig/glib/gstrfuncs.c	2016-12-25 13:21:25.797081984 -0500
+++ glib-2.48.1/glib/gstrfuncs.c	2016-12-25 14:23:07.518480108 -0500
@@ -1272,7 +1272,7 @@
       gchar buf[1024];
       GError *error = NULL;
 
-#if defined(G_OS_WIN32)
+#if defined(G_OS_WIN32) && !defined(__MINGW32__)
       strerror_s (buf, sizeof (buf), errnum);
       msg = buf;
 #elif defined(HAVE_STRERROR_R)
diff -ur glib-2.48.1.orig/glib/gthread-win32.c glib-2.48.1/glib/gthread-win32.c
--- glib-2.48.1.orig/glib/gthread-win32.c	2016-12-25 13:21:25.780081587 -0500
+++ glib-2.48.1/glib/gthread-win32.c	2016-12-25 13:22:17.474289395 -0500
@@ -116,18 +116,28 @@
   void     (__stdcall * WakeConditionVariable)       (gpointer cond);
 } GThreadImplVtable;
 
+/* Needed for static builds where DllMain initializer doesn't get called */
+static gboolean g_threads_is_initialized;
+G_GNUC_INTERNAL void g_thread_win32_init (void);
+
 static GThreadImplVtable g_thread_impl_vtable;
 
 /* {{{1 GMutex */
 void
 g_mutex_init (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.InitializeSRWLock (mutex);
 }
 
 void
 g_mutex_clear (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   if (g_thread_impl_vtable.DeleteSRWLock != NULL)
     g_thread_impl_vtable.DeleteSRWLock (mutex);
 }
@@ -135,18 +145,27 @@
 void
 g_mutex_lock (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.AcquireSRWLockExclusive (mutex);
 }
 
 gboolean
 g_mutex_trylock (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   return g_thread_impl_vtable.TryAcquireSRWLockExclusive (mutex);
 }
 
 void
 g_mutex_unlock (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.ReleaseSRWLockExclusive (mutex);
 }
 
@@ -157,6 +176,9 @@
 {
   CRITICAL_SECTION *cs;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   cs = g_slice_new (CRITICAL_SECTION);
   InitializeCriticalSection (cs);
 
@@ -167,6 +189,10 @@
 g_rec_mutex_impl_free (CRITICAL_SECTION *cs)
 {
   DeleteCriticalSection (cs);
+
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_slice_free (CRITICAL_SECTION, cs);
 }
 
@@ -175,6 +201,9 @@
 {
   CRITICAL_SECTION *impl = mutex->p;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   if G_UNLIKELY (mutex->p == NULL)
     {
       impl = g_rec_mutex_impl_new ();
@@ -189,30 +218,45 @@
 void
 g_rec_mutex_init (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   mutex->p = g_rec_mutex_impl_new ();
 }
 
 void
 g_rec_mutex_clear (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_rec_mutex_impl_free (mutex->p);
 }
 
 void
 g_rec_mutex_lock (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   EnterCriticalSection (g_rec_mutex_get_impl (mutex));
 }
 
 void
 g_rec_mutex_unlock (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   LeaveCriticalSection (mutex->p);
 }
 
 gboolean
 g_rec_mutex_trylock (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   return TryEnterCriticalSection (g_rec_mutex_get_impl (mutex));
 }
 
@@ -221,12 +265,18 @@
 void
 g_rw_lock_init (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.InitializeSRWLock (lock);
 }
 
 void
 g_rw_lock_clear (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   if (g_thread_impl_vtable.DeleteSRWLock != NULL)
     g_thread_impl_vtable.DeleteSRWLock (lock);
 }
@@ -234,36 +284,54 @@
 void
 g_rw_lock_writer_lock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.AcquireSRWLockExclusive (lock);
 }
 
 gboolean
 g_rw_lock_writer_trylock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   return g_thread_impl_vtable.TryAcquireSRWLockExclusive (lock);
 }
 
 void
 g_rw_lock_writer_unlock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.ReleaseSRWLockExclusive (lock);
 }
 
 void
 g_rw_lock_reader_lock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.AcquireSRWLockShared (lock);
 }
 
 gboolean
 g_rw_lock_reader_trylock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   return g_thread_impl_vtable.TryAcquireSRWLockShared (lock);
 }
 
 void
 g_rw_lock_reader_unlock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.ReleaseSRWLockShared (lock);
 }
 
@@ -271,12 +339,18 @@
 void
 g_cond_init (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.InitializeConditionVariable (cond);
 }
 
 void
 g_cond_clear (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   if (g_thread_impl_vtable.DeleteConditionVariable)
     g_thread_impl_vtable.DeleteConditionVariable (cond);
 }
@@ -284,12 +358,18 @@
 void
 g_cond_signal (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.WakeConditionVariable (cond);
 }
 
 void
 g_cond_broadcast (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.WakeAllConditionVariable (cond);
 }
 
@@ -297,6 +377,9 @@
 g_cond_wait (GCond  *cond,
              GMutex *entered_mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.SleepConditionVariableSRW (cond, entered_mutex, INFINITE, 0);
 }
 
@@ -307,6 +390,9 @@
 {
   gint64 span;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   span = end_time - g_get_monotonic_time ();
 
   if G_UNLIKELY (span < 0)
@@ -339,6 +425,9 @@
 
   if G_UNLIKELY (impl == 0)
     {
+      if (!g_threads_is_initialized)
+        g_thread_win32_init ();
+
       EnterCriticalSection (&g_private_lock);
       impl = (DWORD) key->p;
       if (impl == 0)
@@ -432,6 +521,9 @@
 {
   GThreadWin32 *wt = (GThreadWin32 *) thread;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   win32_check_for_error (CloseHandle (wt->handle));
   g_slice_free (GThreadWin32, wt);
 }
@@ -439,6 +531,9 @@
 void
 g_system_thread_exit (void)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   _endthreadex (0);
 }
 
@@ -447,6 +542,9 @@
 {
   GThreadWin32 *self = data;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   self->proxy (self);
 
   g_system_thread_exit ();
@@ -464,6 +562,9 @@
   GThreadWin32 *thread;
   guint ignore;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   thread = g_slice_new0 (GThreadWin32);
   thread->proxy = func;
 
@@ -493,6 +594,9 @@
 {
   GThreadWin32 *wt = (GThreadWin32 *) thread;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   win32_check_for_error (WAIT_FAILED != WaitForSingleObject (wt->handle, INFINITE));
 }
 
@@ -1041,6 +1145,8 @@
 void
 g_thread_win32_init (void)
 {
+  g_threads_is_initialized = TRUE;
+
   if (!g_thread_lookup_native_funcs ())
     g_thread_xp_init ();
 
Only in glib-2.48.1/glib: gthread-win32.c.orig
diff -ur glib-2.48.1.orig/glib-2.0.pc.in glib-2.48.1/glib-2.0.pc.in
--- glib-2.48.1.orig/glib-2.0.pc.in	2016-12-25 13:21:25.734080512 -0500
+++ glib-2.48.1/glib-2.0.pc.in	2016-12-25 13:22:17.469289278 -0500
@@ -3,9 +3,9 @@
 libdir=@libdir@
 includedir=@includedir@
 
-glib_genmarshal=glib-genmarshal
-gobject_query=gobject-query
-glib_mkenums=glib-mkenums
+glib_genmarshal=@bindir@/glib-genmarshal
+gobject_query=@bindir@/gobject-query
+glib_mkenums=@bindir@/glib-mkenums
 
 Name: GLib
 Description: C Utility Library
Only in glib-2.48.1: Makefile.am.orig
Only in glib-2.48.1: Makefile.am.rej
