This file is part of MXE.
See index.html for further information.

Contains ad hoc patches for cross building.

From 2a15b5d8c570d34e44d315116219bcd731054a54 Mon Sep 17 00:00:00 2001
From: "a@mxe.cc" <a@mxe.cc>
Date: Thu, 23 Sep 2010 21:41:51 +0200
Subject: [PATCH 1/7] optional gettext

---
 configure.ac |    4 ++--
 glib/gi18n.h |    5 +++++
 2 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/configure.ac b/configure.ac
index cadd925..241284d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -479,8 +479,8 @@ AC_SUBST([CONFIG_STATUS_DEPENDENCIES],['$(top_srcdir)/po/LINGUAS'])
 GLIB_GNU_GETTEXT
 
 if test "$gt_cv_have_gettext" != "yes" ; then
-  AC_MSG_ERROR([
-*** You must have either have gettext support in your C library, or use the 
+  AC_MSG_WARN([
+*** You should have either have gettext support in your C library, or use the
 *** GNU gettext library. (http://www.gnu.org/software/gettext/gettext.html
 ])
 fi
diff --git a/glib/gi18n.h b/glib/gi18n.h
index c710046..269bfdf 100644
--- a/glib/gi18n.h
+++ b/glib/gi18n.h
@@ -22,7 +22,12 @@
 
 #include <glib.h>
 
+#ifdef ENABLE_NLS
 #include <libintl.h>
+#else
+#define gettext(String) (String)
+#endif
+
 #include <string.h>
 
 #define  _(String) gettext (String)
-- 
1.7.10.4


From 6e19d772238eb429fe0ea77b65dbc9d8a5d89afa Mon Sep 17 00:00:00 2001
From: "a@mxe.cc" <a@mxe.cc>
Date: Thu, 23 Sep 2010 21:42:46 +0200
Subject: [PATCH 2/7] fix tool paths

---
 glib-2.0.pc.in |    6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/glib-2.0.pc.in b/glib-2.0.pc.in
index 4a8898e..5164bae 100644
--- a/glib-2.0.pc.in
+++ b/glib-2.0.pc.in
@@ -3,9 +3,9 @@ exec_prefix=@exec_prefix@
 libdir=@libdir@
 includedir=@includedir@
 
-glib_genmarshal=glib-genmarshal
-gobject_query=gobject-query
-glib_mkenums=glib-mkenums
+glib_genmarshal=@bindir@/glib-genmarshal
+gobject_query=@bindir@/gobject-query
+glib_mkenums=@bindir@/glib-mkenums
 
 Name: GLib
 Description: C Utility Library
-- 
1.7.10.4


From 556504bac07f4d80c0d9e50be1090f3ae02a653b Mon Sep 17 00:00:00 2001
From: Hans Petter Jansson <hpj@cl.no>
Date: Fri, 15 Jun 2012 15:25:01 +0200
Subject: [PATCH 3/7] Avoid DllMain symbol conflict when linking statically

---
 gio/giomodule.c  |    6 +-----
 glib/glib-init.c |    6 +++---
 2 files changed, 4 insertions(+), 8 deletions(-)

diff --git a/gio/giomodule.c b/gio/giomodule.c
index d8ce138..679279f 100644
--- a/gio/giomodule.c
+++ b/gio/giomodule.c
@@ -782,10 +782,8 @@ extern GType _g_network_monitor_netlink_get_type (void);
 
 static HMODULE gio_dll = NULL;
 
-#ifdef DLL_EXPORT
-
 BOOL WINAPI
-DllMain (HINSTANCE hinstDLL,
+gio_DllMain (HINSTANCE hinstDLL,
 	 DWORD     fdwReason,
 	 LPVOID    lpvReserved)
 {
@@ -801,8 +799,6 @@ _g_io_win32_get_module (void)
   return gio_dll;
 }
 
-#endif
-
 #undef GIO_MODULE_DIR
 
 /* GIO_MODULE_DIR is used only in code called just once,
diff --git a/glib/glib-init.c b/glib/glib-init.c
index f4edd5c..02bf678 100644
--- a/glib/glib-init.c
+++ b/glib/glib-init.c
@@ -226,9 +226,9 @@ glib_init (void)
 HMODULE glib_dll;
 
 BOOL WINAPI
-DllMain (HINSTANCE hinstDLL,
-         DWORD     fdwReason,
-         LPVOID    lpvReserved)
+glib_DllMain (HINSTANCE hinstDLL,
+              DWORD     fdwReason,
+              LPVOID    lpvReserved)
 {
   switch (fdwReason)
     {
-- 
1.7.10.4


From a83efeaa712bdfe43a1fcada6775ce2c89781631 Mon Sep 17 00:00:00 2001
From: Hans Petter Jansson <hpj@cl.no>
Date: Fri, 15 Jun 2012 15:27:22 +0200
Subject: [PATCH 4/7] Allow building without inotify support

---
 configure.ac |   13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/configure.ac b/configure.ac
index 241284d..04d8590 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1700,11 +1700,18 @@ dnl *****************************
 dnl ** Check for inotify (GIO) **
 dnl *****************************
 inotify_support=no
-AC_CHECK_HEADERS([sys/inotify.h],
-[
+
+AC_ARG_ENABLE(inotify,
+              AC_HELP_STRING([--disable-inotify],
+                             [build without inotify support]))
+
+if test "x$enable_inotify" != "xno"; then
+ AC_CHECK_HEADERS([sys/inotify.h],
+ [
 	inotify_support=yes
 	AC_CHECK_FUNCS(inotify_init1)
-])
+ ])
+fi
 
 AM_CONDITIONAL(HAVE_INOTIFY, [test "$inotify_support" = "yes"])
 
-- 
1.7.10.4


From e3d193f7e4f3d1ada0d65ccdccab1f28ef6d23d3 Mon Sep 17 00:00:00 2001
From: Hans Petter Jansson <hpj@cl.no>
Date: Fri, 15 Jun 2012 15:28:14 +0200
Subject: [PATCH 5/7] Make sure STDC_HEADERS is set for AC_CHECK_ALIGNOF.
 Backported from upstream

---
 configure.ac |    2 ++
 1 file changed, 2 insertions(+)

diff --git a/configure.ac b/configure.ac
index 04d8590..29b6252 100644
--- a/configure.ac
+++ b/configure.ac
@@ -452,6 +452,8 @@ fi
 
 AC_MSG_RESULT($enable_iconv_cache)
 
+# Make sure STDC_HEADERS is set for AC_CHECK_ALIGNOF
+AS_IF([false], [AC_CHECK_HEADER([stdint.h])])
 
 dnl
 dnl zlib support
-- 
1.7.10.4


From 08b493b8480f360ab21a0ce5c79b096392a389a8 Mon Sep 17 00:00:00 2001
From: Hans Petter Jansson <hpj@cl.no>
Date: Fri, 15 Jun 2012 15:29:06 +0200
Subject: [PATCH 6/7] Link with dnsapi

---
 gio-2.0.pc.in |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/gio-2.0.pc.in b/gio-2.0.pc.in
index 9f7123f..b0d5779 100644
--- a/gio-2.0.pc.in
+++ b/gio-2.0.pc.in
@@ -13,6 +13,6 @@ Description: glib I/O library
 Version: @VERSION@
 Requires: glib-2.0 gobject-2.0
 Requires.private: gmodule-no-export-2.0
-Libs: -L${libdir} -lgio-2.0
+Libs: -L${libdir} -lgio-2.0 -ldnsapi
 Libs.private: @ZLIB_LIBS@ @NETWORK_LIBS@
 Cflags:
-- 
1.7.10.4


From 645849d2055b1c7a46132a8b83739290b316ffba Mon Sep 17 00:00:00 2001
From: Hans Petter Jansson <hpj@cl.no>
Date: Fri, 15 Jun 2012 15:29:38 +0200
Subject: [PATCH 7/7] Ensure globals are initialized even when DllMain is not
 being run

---
 glib/gmain.c         |    6 +++
 glib/gthread-win32.c |  106 ++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 112 insertions(+)

diff --git a/glib/gmain.c b/glib/gmain.c
index 760f179..878ac14 100644
--- a/glib/gmain.c
+++ b/glib/gmain.c
@@ -1981,12 +1981,15 @@ g_get_real_time (void)
 #ifdef G_OS_WIN32
 static ULONGLONG (*g_GetTickCount64) (void) = NULL;
 static guint32 g_win32_tick_epoch = 0;
+static gboolean g_win32_clock_is_initialized;
 
 G_GNUC_INTERNAL void
 g_clock_win32_init (void)
 {
   HMODULE kernel32;
 
+  g_win32_clock_is_initialized = TRUE;
+
   g_GetTickCount64 = NULL;
   kernel32 = GetModuleHandle ("KERNEL32.DLL");
   if (kernel32 != NULL)
@@ -2105,6 +2108,9 @@ g_get_monotonic_time (void)
    *    timeBeginPeriod() to increase it as much as they want
    */
 
+  if (!g_win32_clock_is_initialized)
+    g_clock_win32_init ();
+
   if (g_GetTickCount64 != NULL)
     {
       guint32 ticks_as_32bit;
diff --git a/glib/gthread-win32.c b/glib/gthread-win32.c
index 5a9ac97..e4d1d48 100644
--- a/glib/gthread-win32.c
+++ b/glib/gthread-win32.c
@@ -117,18 +117,28 @@ typedef struct
   void     (__stdcall * WakeConditionVariable)       (gpointer cond);
 } GThreadImplVtable;
 
+/* Needed for static builds where DllMain initializer doesn't get called */
+static gboolean g_threads_is_initialized;
+G_GNUC_INTERNAL void g_thread_win32_init (void);
+
 static GThreadImplVtable g_thread_impl_vtable;
 
 /* {{{1 GMutex */
 void
 g_mutex_init (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.InitializeSRWLock (mutex);
 }
 
 void
 g_mutex_clear (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   if (g_thread_impl_vtable.DeleteSRWLock != NULL)
     g_thread_impl_vtable.DeleteSRWLock (mutex);
 }
@@ -136,18 +146,27 @@ g_mutex_clear (GMutex *mutex)
 void
 g_mutex_lock (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.AcquireSRWLockExclusive (mutex);
 }
 
 gboolean
 g_mutex_trylock (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   return g_thread_impl_vtable.TryAcquireSRWLockExclusive (mutex);
 }
 
 void
 g_mutex_unlock (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.ReleaseSRWLockExclusive (mutex);
 }
 
@@ -158,6 +177,9 @@ g_rec_mutex_impl_new (void)
 {
   CRITICAL_SECTION *cs;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   cs = g_slice_new (CRITICAL_SECTION);
   InitializeCriticalSection (cs);
 
@@ -168,6 +190,10 @@ static void
 g_rec_mutex_impl_free (CRITICAL_SECTION *cs)
 {
   DeleteCriticalSection (cs);
+
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_slice_free (CRITICAL_SECTION, cs);
 }
 
@@ -176,6 +202,9 @@ g_rec_mutex_get_impl (GRecMutex *mutex)
 {
   CRITICAL_SECTION *impl = mutex->p;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   if G_UNLIKELY (mutex->p == NULL)
     {
       impl = g_rec_mutex_impl_new ();
@@ -190,30 +219,45 @@ g_rec_mutex_get_impl (GRecMutex *mutex)
 void
 g_rec_mutex_init (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   mutex->p = g_rec_mutex_impl_new ();
 }
 
 void
 g_rec_mutex_clear (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_rec_mutex_impl_free (mutex->p);
 }
 
 void
 g_rec_mutex_lock (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   EnterCriticalSection (g_rec_mutex_get_impl (mutex));
 }
 
 void
 g_rec_mutex_unlock (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   LeaveCriticalSection (mutex->p);
 }
 
 gboolean
 g_rec_mutex_trylock (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   return TryEnterCriticalSection (g_rec_mutex_get_impl (mutex));
 }
 
@@ -222,12 +266,18 @@ g_rec_mutex_trylock (GRecMutex *mutex)
 void
 g_rw_lock_init (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.InitializeSRWLock (lock);
 }
 
 void
 g_rw_lock_clear (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   if (g_thread_impl_vtable.DeleteSRWLock != NULL)
     g_thread_impl_vtable.DeleteSRWLock (lock);
 }
@@ -235,36 +285,54 @@ g_rw_lock_clear (GRWLock *lock)
 void
 g_rw_lock_writer_lock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.AcquireSRWLockExclusive (lock);
 }
 
 gboolean
 g_rw_lock_writer_trylock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   return g_thread_impl_vtable.TryAcquireSRWLockExclusive (lock);
 }
 
 void
 g_rw_lock_writer_unlock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.ReleaseSRWLockExclusive (lock);
 }
 
 void
 g_rw_lock_reader_lock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.AcquireSRWLockShared (lock);
 }
 
 gboolean
 g_rw_lock_reader_trylock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   return g_thread_impl_vtable.TryAcquireSRWLockShared (lock);
 }
 
 void
 g_rw_lock_reader_unlock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.ReleaseSRWLockShared (lock);
 }
 
@@ -272,12 +340,18 @@ g_rw_lock_reader_unlock (GRWLock *lock)
 void
 g_cond_init (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.InitializeConditionVariable (cond);
 }
 
 void
 g_cond_clear (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   if (g_thread_impl_vtable.DeleteConditionVariable)
     g_thread_impl_vtable.DeleteConditionVariable (cond);
 }
@@ -285,12 +359,18 @@ g_cond_clear (GCond *cond)
 void
 g_cond_signal (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.WakeConditionVariable (cond);
 }
 
 void
 g_cond_broadcast (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.WakeAllConditionVariable (cond);
 }
 
@@ -298,6 +378,9 @@ void
 g_cond_wait (GCond  *cond,
              GMutex *entered_mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   g_thread_impl_vtable.SleepConditionVariableSRW (cond, entered_mutex, INFINITE, 0);
 }
 
@@ -308,6 +391,9 @@ g_cond_wait_until (GCond  *cond,
 {
   gint64 span;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   span = end_time - g_get_monotonic_time ();
 
   if G_UNLIKELY (span < 0)
@@ -340,6 +426,9 @@ g_private_get_impl (GPrivate *key)
 
   if G_UNLIKELY (impl == 0)
     {
+      if (!g_threads_is_initialized)
+        g_thread_win32_init ();
+
       EnterCriticalSection (&g_private_lock);
       impl = (DWORD) key->p;
       if (impl == 0)
@@ -433,6 +522,9 @@ g_system_thread_free (GRealThread *thread)
 {
   GThreadWin32 *wt = (GThreadWin32 *) thread;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   win32_check_for_error (CloseHandle (wt->handle));
   g_slice_free (GThreadWin32, wt);
 }
@@ -440,6 +532,9 @@ g_system_thread_free (GRealThread *thread)
 void
 g_system_thread_exit (void)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   _endthreadex (0);
 }
 
@@ -448,6 +543,9 @@ g_thread_win32_proxy (gpointer data)
 {
   GThreadWin32 *self = data;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   self->proxy (self);
 
   g_system_thread_exit ();
@@ -465,6 +563,9 @@ g_system_thread_new (GThreadFunc   func,
   GThreadWin32 *thread;
   guint ignore;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   thread = g_slice_new0 (GThreadWin32);
   thread->proxy = func;
 
@@ -494,6 +595,9 @@ g_system_thread_wait (GRealThread *thread)
 {
   GThreadWin32 *wt = (GThreadWin32 *) thread;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init ();
+
   win32_check_for_error (WAIT_FAILED != WaitForSingleObject (wt->handle, INFINITE));
 }
 
@@ -985,6 +1089,8 @@ g_thread_lookup_native_funcs (void)
 G_GNUC_INTERNAL void
 g_thread_win32_init (void)
 {
+  g_threads_is_initialized = TRUE;
+
   if (!g_thread_lookup_native_funcs ())
     g_thread_xp_init ();
 
-- 
1.7.10.4

